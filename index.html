<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bebop Blueprint</title>
  <link rel="icon" type="image/png" href="es335icon.png" />
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    /* Global styles */
    body {
      font-family: 'Lato', sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #1f618d;
      transition: background-color 0.3s;
/* Update these CSS rules */
body.dark-mode {
    background-color: #1f618d;
}

.app-section {
    background: white;
    transition: background-color 0.3s;
}

body.dark-mode .app-section {
    background-color: #6096ba;
}

body.dark-mode .fretboard-container {
    background: #6096ba;
    color: white;
}
    .fretboards-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      margin-bottom: 30px;
    }
    .fretboard-container {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s;
    }
    body.dark-mode .fretboard-container {
      background: #6096ba;
    }
    .scale-display {
      font-size: 1.2em;
      font-weight: bold;
      text-align: center;
      margin-bottom: 15px;
      color: #333;
    }
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    .fretboard {
      position: relative;
      height: 200px;
      background-color: #FFCF79;
      border-radius: 5px;
      margin-bottom: 30px;
      border: 2px solid #4B1C2E;
      overflow: visible;
    }
    .fret-line {
      position: absolute;
      top: 0;
      height: 100%;
      width: 2px;
      background: #c0c0c0;
      border-right: 1px solid rgba(0, 0, 0, 0.3);
      z-index: 1;
    }
    .string-line {
      position: absolute;
      left: 0;
      width: 100%;
      height: 1px;
      background: silver;
      border-bottom: 1px solid rgba(0, 0, 0, 0.3);
      z-index: 0;
    }
    .fret-number {
      position: absolute;
      bottom: -40px;
      font-size: 16px;
      color: #1f618d;
      transform: translateX(-50%);
      font-weight: bold;
      z-index: 2;
      width: 20px;
      text-align: center;
    }
    .note {
      position: absolute;
      width: 25px;
      height: 25px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: white;
      z-index: 3;
      cursor: pointer;
      transform: translate(-50%, -50%);
      transition: transform 0.1s ease;
    }
    .note:hover {
      transform: translate(-50%, -50%) scale(1.2);
    }
    .beat {
      width: 40px;
      height: 80px;
      background: #9E9E9E;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: white;
      font-weight: bold;
      transition: all 0.2s ease;
      font-size: 14px;
      margin: 0 2px;
    }
    .beat.active {
      transform: translateY(-10px);
    }
    .beats-container {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin: 20px 0;
    }
    #measures {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 20px;
    }
    .measure {
      position: relative;
      background-color: #e9ecef;
      padding: 15px;
      border-radius: 4px;
      transition: opacity 0.2s ease;
    }
    .measure.dragging {
      opacity: 0.5;
    }
    .measure.active {
      background-color: #c3e6cb;
      border: 2px solid #28a745;
    }
    .measure-number {
      position: absolute;
      top: 5px;
      right: 5px;
      font-size: 12px;
      color: #333;
    }
    .chord-controls,
    .scale-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .chord-controls select,
    .scale-controls select {
      flex: 1;
    }
    @media (max-width: 1200px) {
      #measures {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 600px) {
      #measures {
        grid-template-columns: 1fr;
      }
    }
    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      background: #4CAF50;
      color: white;
      cursor: pointer;
    }
    select {
      padding: 5px;
      margin: 5px;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    #tempo-display {
      font-size: 1.2em;
      font-weight: bold;
      margin: 0 10px;
    }
    #loading-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 5px;
      z-index: 1000;
    }
      .dark-mode-toggle {
    position: fixed;
    top: 20px;
    right: 20px;  /* Changed from left to right */
    padding: 10px 15px;
    background: #333;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    z-index: 1000;
}
  </style>
</head>
<body>
  <button class="dark-mode-toggle" id="dark-mode-toggle">Toggle Dark Mode</button>
  <div class="app-section" id="chord-fretboard-section">
    <h1>BEBOP BLUEPRINT</h1>
    <h3>Fretflow - Dynamic Fretboard with Scales that Move with the Chord Progression</h3>
    <div class="volume-control">
      <span>Fretboard Volume:</span>
      <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.1" value="0.3" />
    </div>
    <div class="fretboard-container">
      <div class="scale-display" id="scale-display"></div>
      <div class="controls">
        <select class="tuning-select" id="chord-tuning">
          <option value="standard">Standard (EADGBE)</option>
          <option value="dropD">Drop D (DADGBE)</option>
          <option value="openG">Open G (DGDGBD)</option>
          <option value="DADGAD">DADGAD</option>
          <option value="openE">Open E (EBEG#BE)</option>
        </select>
      </div>
      <div id="chord-fretboard" class="fretboard"></div>
    </div>
  </div>

  <div class="app-section" id="metronome-section">
    <h2>BeatForge Metronome</h2>
    <h3>Click to accent strong beats</h3>
    <div class="controls">
      <select id="time-signature">
        <option value="2">2/4</option>
        <option value="3">3/4</option>
        <option value="4" selected>4/4</option>
        <option value="6">6/8</option>
        <option value="7">7/8</option>
        <option value="8">8/8</option>
        <option value="12">12/8</option>
      </select>
      <select id="sound-type">
        <option value="click">Click</option>
        <option value="drums">Drums</option>
        <option value="woodblock">Woodblock</option>
      </select>
      <div class="volume-control">
        <span>Metronome Volume:</span>
        <input type="range" id="metronome-volume" min="0" max="1" step="0.1" value="0.7" />
      </div>
      <input type="range" id="tempo" min="40" max="220" value="120" />
      <span id="tempo-display">120 BPM</span>
      <button id="tap-tempo">Tap Tempo</button>
      <button id="start-stop">Start</button>
      <button id="cycle-sound">Cycle Sound</button>
    </div>
    <div class="beats-container">
      <!-- Beats will be generated dynamically -->
    </div>
  </div>

  <div class="app-section" id="chord-progression-section">
    <h2>Chord Progression Practice</h2>
    <h3>Create a progression or pick one from the dropdown. Choose which key and scale to go with it.</h3>
    <label for="progression-select">Select Progression:</label>
    <select id="progression-select">
      <option value="iv">I-V</option>
      <option value="jazz_blues">Jazz Blues</option>
      <option value="minor_blues">Minor Blues</option>
      <option value="rhythm_changes">Rhythm Changes</option>
      <option value="2_5_1">II-V-I</option>
      <option value="6_2_5_1">VI-II-V-I</option>
      <option value="minor 2_5_1">Minor iim-V7-im</option>
      <option value="dark_eyes">Dark Eyes</option>
      <option value="black_orpheus">Black Orpheus</option>
      <option value="all_the_things_you_are">All The Things You Are</option>
      <option value="all_of_me">All of Me</option>
      <option value="stella_by_starlight">Stella By Starlight</option>
      <option value="autumn_leaves">Autumn Leaves</option>
      <option value="summertime">Summertime</option>
      <option value="girl_from_ipanema">Girl From Ipanema</option>
      <option value="coltrane_changes">Coltrane Changes</option>
      <option value="bird_blues">Bird Blues</option>
    </select>
    <label for="keySelect">Select Key:</label>
    <select id="keySelect">
      ${["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"].map(n => `<option value="${n}">${n}</option>`).join('')}
    </select>

    <div id="measures">
      <!-- Measures will load automatically based on progression -->
    </div>
    <button onclick="addMeasure()">Add Measure</button>
    <button onclick="removeMeasure()">Remove Measure</button>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="chordsEnabled" checked />
      <label for="chordsEnabled">Enable Chords</label>
    </div>
    <div class="volume-control">
      <label for="chord-volume">Chord Volume:</label>
      <input type="range" id="chord-volume" min="0" max="1" step="0.1" value="0.75" />
    </div>
  </div>

  <div class="app-section" id="fretflow-section">
    <h2>FretFlow</h2>
    <h3>Multiple scale workout</h3>
    <div class="volume-control">
      <span>Fretboard Volume:</span>
      <input type="range" id="fretboard-volume" min="0" max="1" step="0.1" value="0.3" />
    </div>
    <div class="fretboards-grid">
      <!-- Fretboards will be generated dynamically -->
    </div>
  </div>

  <script>
    // Global state variables and audio context initialization
    let audioContext = null;
    let isPlaying = false;
    let currentBeat = 0;
    let currentMeasure = 0;
    let intervalId = null;
    let tempo = 120;
    let tapTimes = [];
    let lastTapTime = 0;
    let currentChordGain = null;
    let soundBuffers = {};
    let reverbNode = null;
    let pianoSampleBuffers = {};
    let samplesLoaded = false;
    let metronomeSoundIndex = 0;

    // Note and sample constants
    const NOTES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const noteMap = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const ENHARMONIC_MAP = {
      "C#": "Db", "D#": "Eb", "F#": "Gb", "G#": "Ab", "A#": "Bb",
      "Db": "Db", "Eb": "Eb", "Gb": "Gb", "Ab": "Ab", "Bb": "Bb"
    };

    // Standardizes note names to use flat notation when available
    function standardizeNoteName(note) {
      return ENHARMONIC_MAP[note] || note;
    }

    // Get note index using standardized name
    function getNoteIndex(note) {
      return NOTES.indexOf(standardizeNoteName(note));
    }

    // Default progression definitions, including our new "I-V" progression.
    // "I-V" will be interpreted as C major to G7 if key is C.
    const progressions = {
      "iv": { // using "iv" key from dropdown for I-V default progression.
        defaultKey: "C",
        progression: ["I", "V7"]
      },
      "jazz_blues": {
        defaultKey: "Bb",
        progression: ["I7", "IV7", "I7", "I7", "IV7", "IV7", "I7", "VI7", "II7", "V7", "I7", "V7"]
      },
      "minor_blues": {
        defaultKey: "Am",
        progression: ["Im7", "IVm7", "Im7", "Im7", "bVI7", "V7", "Im7", "IVm7", "Im7", "bVII7", "Im7", "V7"]
      },
      "rhythm_changes": {
        defaultKey: "Bb",
        progression: ["I", "vi", "ii", "V", "I", "vi", "ii", "V", "I", "IV", "I", "I", "ii", "V", "I", "V7"]
      },
      "2_5_1": {
        defaultKey: "C",
        progression: ["ii", "V", "I", "I"]
      },
      "6_2_5_1": {
        defaultKey: "C",
        progression: ["vi", "ii", "V", "I"]
      },
      "minor 2_5_1": {
        defaultKey: "Am",
        progression: ["iim7b5", "V7b9", "im7", "im7"]
      },
      "dark_eyes": {
        defaultKey: "Am",
        progression: ["i", "iv", "V7", "i", "iv", "V7", "i", "V7/iv", "iv", "V7/III", "III", "i", "iv", "V7", "i", "V7"]
      },
      "black_orpheus": {
        defaultKey: "Am",
        progression: ["im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7"]
      },
      "all_the_things_you_are": {
        defaultKey: "Ab",
        progression: ["vim7", "iim7", "V7", "Imaj7", "IVmaj7", "iiim7", "VI7", "IImaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7", "iim7", "V7", "bIIImaj7", "iim7", "V7", "bIIImaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7"]
      },
      "all_of_me": {
        defaultKey: "C",
        progression: ["Imaj7", "III7", "VI7", "iim7", "III7", "vim7", "II7", "iim7", "V7", "Imaj7", "III7", "VI7", "iim7", "IV", "bv", "Imaj7", "V7"]
      },
      "stella_by_starlight": {
        defaultKey: "Bb",
        progression: ["iim7b5", "V7b9", "im7", "IV7", "vm7", "I7", "IVmaj7", "bVIImaj7", "iiim7b5", "VI7b9", "im7", "IV7", "vm7", "I7", "IVmaj7", "VI7b9"]
      },
      "autumn_leaves": {
        defaultKey: "Bb",
        progression: ["iim7b5", "V7b9", "im7", "ivm7", "bVII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "ivm7", "bVII7", "bIIImaj7", "bVImaj7", "V7b9"]
      },
      "summertime": {
        defaultKey: "Am",
        progression: ["i", "V7", "i", "V7", "i", "V7", "i", "V7", "iv", "i", "V7", "i", "iv", "i", "V7", "i"]
      },
      "girl_from_ipanema": {
        defaultKey: "F",
        progression: ["Imaj7", "II7", "iim7", "V7", "Imaj7", "II7", "iim7", "V7", "Imaj7", "bII7", "Vmaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7"]
      },
      "coltrane_changes": {
        defaultKey: "C",
        progression: ["Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7", "Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7"]
      },
      "bird_blues": {
        defaultKey: "F",
        progression: ["I7", "IV7", "I7", "vim7", "I7", "IV7", "IV7", "bvo7", "I7", "vim7", "II7", "iim7", "V7"]
      }
    };

    // Tuning configurations
    const TUNINGS = {
      standard: ['E', 'B', 'G', 'D', 'A', 'E'],
      dropD: ['E', 'B', 'G', 'D', 'A', 'D'],
      openG: ['D', 'B', 'G', 'D', 'G', 'D'],
      DADGAD: ['D', 'A', 'G', 'D', 'A', 'D'],
      openE: ['E', 'B', 'E', 'G#', 'B', 'E']
    };

    // Drum Patterns including improved 4/4 pattern that uses eighth notes.
    const DRUM_PATTERNS = {
      '2': { kick: [1, 0], snare: [0, 1], hihat: [1, 1] },
      '3': { kick: [1, 0, 0], snare: [0, 1, 0], hihat: [1, 1, 1] },
      '4': {
        // In 4/4 we use 8 beats (eighth notes)
        kick: [1, 0, 0, 0, 1, 0, 0, 0],
        snare: [0, 0, 1, 0, 0, 0, 1, 0],
        hihat: [1, 1, 1, 1, 1, 1, 1, 1]
      },
      '6': { kick: [1, 0, 0, 1, 0, 0], snare: [0, 0, 1, 0, 0, 1], hihat: [1, 1, 1, 1, 1, 1] },
      '7': { kick: [1, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1] },
      '8': { kick: [1, 0, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1, 1] },
      '12': { kick: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], snare: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], hihat: [1,1,1,1,1,1,1,1,1,1,1,1] }
    };

    // Audio initialization functions:
    async function initAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        await loadSounds();
        await setupReverb();
      }
      return audioContext;
    }

    async function initializeAudio() {
      try {
        if (!audioContext) {
          audioContext = await initAudioContext();
        }
        if (audioContext.state === 'suspended') await audioContext.resume();
        if (!Object.keys(soundBuffers).length) await loadSounds();
        if (!samplesLoaded) await loadPianoSamples();
        return audioContext.state === 'running';
      } catch (error) {
        console.error("Audio initialization failed:", error);
        updateLoadingStatus("Audio initialization failed. Please refresh the page.");
        return false;
      }
    }

    function updateLoadingStatus(message) {
      let indicator = document.getElementById('loading-indicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'loading-indicator';
        document.body.appendChild(indicator);
      }
      indicator.textContent = message;
    }

    async function loadSounds() {
      try {
        const baseUrl = "./";
        const soundFiles = {
          click: 'Click.wav',
          hihat: 'HiHat.wav',
          kick: 'Kick.wav',
          snare: 'Snare.wav',
          woodblock: 'woodblock.wav'
        };
        for (let [type, filename] of Object.entries(soundFiles)) {
          try {
            const response = await fetch(baseUrl + filename);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const arrayBuffer = await response.arrayBuffer();
            soundBuffers[type] = await audioContext.decodeAudioData(arrayBuffer);
          } catch (error) {
            console.error(`Failed to load ${filename}:`, error);
            soundBuffers[type] = await createDrumSound(type);
          }
        }
        updateLoadingStatus("Drum sounds loaded");
        return true;
      } catch (error) {
        console.error("Error in loadSounds:", error);
        return false;
      }
    }

    async function setupReverb() {
      if (!audioContext) audioContext = await initAudioContext();
      if (!reverbNode) {
        reverbNode = audioContext.createConvolver();
        const sampleRate = audioContext.sampleRate;
        const length = sampleRate * 2.5;
        const impulse = audioContext.createBuffer(2, length, sampleRate);
        for (let channel = 0; channel < 2; channel++) {
          const channelData = impulse.getChannelData(channel);
          for (let i = 0; i < length; i++) {
            channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
          }
        }
        reverbNode.buffer = impulse;
        reverbNode.connect(audioContext.destination);
      }
    }

    async function createDrumSound(type) {
      const sampleRate = audioContext.sampleRate;
      const duration = type === 'hihat' ? 0.05 : 0.2;
      const buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
      const data = buffer.getChannelData(0);
      switch (type) {
        case 'click':
          for (let i = 0; i < data.length; i++) data[i] = Math.sin(i * 0.05) * Math.exp(-i * 0.01);
          break;
        case 'hihat':
          for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.01));
          break;
        case 'kick':
          for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            data[i] = Math.sin(2 * Math.PI * 100 * t) * Math.exp(-t * 10) * 2;
          }
          break;
        case 'snare':
          for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            data[i] = ((Math.random() * 2 - 1) + Math.sin(2 * Math.PI * 200 * t)) * Math.exp(-t * 10) * 2;
          }
          break;
        case 'woodblock':
          for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            data[i] = Math.sin(2 * Math.PI * 800 * t) * Math.exp(-t * 20);
          }
          break;
      }
      return buffer;
    }

    async function loadPianoSamples() {
      if (!audioContext) await initializeAudio();
      const SAMPLED_NOTES = ['A', 'C', 'Ds', 'Fs'];
      const PIANO_CONFIG = {
        octaves: { A: [2,3,4,5,6], C: [2,3,4,5,6], Fs: [2,3,4,5,6], Ds: [2,3,4,5,6] },
        velocities: [12],
        fileFormat: 'ogg'
      };
      const baseUrl = "./";
      const loadPromises = [];
      for (let note of SAMPLED_NOTES) {
        for (let octave of PIANO_CONFIG.octaves[note]) {
          const sampleName = `${note}${octave}v12`;
          const fileName = `${sampleName}.ogg`;
          const loadPromise = (async () => {
            try {
              const response = await fetch(baseUrl + fileName);
              if (!response.ok) return null;
              const arrayBuffer = await response.arrayBuffer();
              const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
              return { name: sampleName, buffer: audioBuffer };
            } catch (error) {
              return null;
            }
          })();
          loadPromises.push(loadPromise);
        }
      }
      const results = await Promise.all(loadPromises);
      let loadedCount = 0;
      results.forEach(result => {
        if (result) {
          pianoSampleBuffers[result.name] = result.buffer;
          loadedCount++;
        }
      });
      samplesLoaded = loadedCount > 0;
    }

    // Helper to play a sound from buffer
    function playBuffer(buffer, volume) {
      const source = audioContext.createBufferSource();
      const gainNode = audioContext.createGain();
      source.buffer = buffer;
      gainNode.gain.value = volume;
      source.connect(gainNode);
      gainNode.connect(audioContext.destination);
      source.start();
    }

    // Dark Mode Toggle function
    document.getElementById("dark-mode-toggle").addEventListener("click", function () {
      document.body.classList.toggle("dark-mode");
    });

    // Metronome: cycle through sounds
    const METRONOME_SOUNDS = ['default', 'kick', 'kick-half', 'snare', 'snare-half', 'hihat', 'silent'];
    function cycleMetronomeSound() {
      metronomeSoundIndex = (metronomeSoundIndex + 1) % METRONOME_SOUNDS.length;
      return METRONOME_SOUNDS[metronomeSoundIndex];
    }
    document.getElementById("cycle-sound").addEventListener("click", function () {
      const newSound = cycleMetronomeSound();
      console.log("Metronome sound toggled to: ", newSound);
      // Optionally update UI feedback for metronome sound.
    });

    // playMetronomeSound revised to handle 4/4 with proper drum pattern and toggleable metronome sound
    async function playMetronomeSound(volume) {
      if (!audioContext || audioContext.state === 'suspended') {
        await initializeAudio();
        return;
      }
      const soundType = document.getElementById("sound-type").value;
      const metronomeVolume = parseFloat(document.getElementById("metronome-volume").value) || 0.7;
      const timeSignature = parseInt(document.getElementById("time-signature").value);
      const beats = document.querySelectorAll(".beat");
      const currentBeatElement = beats[currentBeat];
      const finalVolume = volume * metronomeVolume;
      if (!currentBeatElement || finalVolume <= 0) return;
      // Use metronomeSoundIndex toggled value if desired
      const beatSound = currentBeatElement.dataset.sound || cycleMetronomeSound();

      if (soundType === "click") {
        // Click plays on quarter notes only in 4/4
        if (timeSignature === 4) {
          if (currentBeat % 2 === 0) playBuffer(soundBuffers["click"] || createDrumSound("click"), finalVolume);
        } else {
          playBuffer(soundBuffers["click"] || createDrumSound("click"), finalVolume);
        }
      } else if (soundType === "woodblock") {
        // Woodblock on quarter notes only in 4/4
        if (timeSignature === 4) {
          if (currentBeat % 2 === 0) playBuffer(soundBuffers["woodblock"] || createDrumSound("woodblock"), finalVolume);
        } else {
          playBuffer(soundBuffers["woodblock"] || createDrumSound("woodblock"), finalVolume);
        }
      } else if (soundType === "drums") {
        if (timeSignature === 4) {
          // In 4/4 with eighth notes:
          playBuffer(soundBuffers["hihat"] || createDrumSound("hihat"), finalVolume * 0.7);
          if (currentBeat === 0 || currentBeat === 4) {
            playBuffer(soundBuffers["kick"] || createDrumSound("kick"), finalVolume);
          } else if (currentBeat === 2 || currentBeat === 6) {
            playBuffer(soundBuffers["snare"] || createDrumSound("snare"), finalVolume);
          }
        } else {
          const pattern = DRUM_PATTERNS[timeSignature];
          if (pattern) {
            if (pattern.hihat[currentBeat]) playBuffer(soundBuffers["hihat"] || createDrumSound("hihat"), finalVolume * 0.7);
            if (pattern.kick[currentBeat]) playBuffer(soundBuffers["kick"] || createDrumSound("kick"), finalVolume);
            if (pattern.snare[currentBeat]) playBuffer(soundBuffers["snare"] || createDrumSound("snare"), finalVolume);
          }
        }
      }
    }

    // Chord and note playing functions
    function playNote(note, string, fret) {
      if (!audioContext || audioContext.state === 'suspended') {
        initializeAudio().then(() => playNote(note, string, fret));
        return;
      }
      const tuning = TUNINGS[document.getElementById("chord-tuning").value] || TUNINGS.standard;
      const openNote = tuning[string];
      const openNoteIndex = NOTES.indexOf(openNote);
      const noteIndex = (openNoteIndex + fret) % 12;
      const targetNote = NOTES[noteIndex];
      const octave = Math.floor((openNoteIndex + fret) / 12) + 2;
      const volume = parseFloat(document.getElementById("chord-fretboard-volume").value) || 0.3;
      if (samplesLoaded && pianoSampleBuffers) {
        const nearest = findNearestSampledNote(targetNote, octave);
        if (nearest && pianoSampleBuffers[nearest.sampleKey]) {
          const source = audioContext.createBufferSource();
          const gainNode = audioContext.createGain();
          source.buffer = pianoSampleBuffers[nearest.sampleKey];
          source.playbackRate.value = Math.pow(2, nearest.semitoneDiff/12);
          gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
          source.connect(gainNode);
          gainNode.connect(audioContext.destination);
          source.start();
          source.stop(audioContext.currentTime + 5);
        } else {
          playFallbackNote(targetNote, octave, volume, 5);
        }
      } else {
        playFallbackNote(targetNote, octave, volume, 5);
      }
    }

    function playFallbackNote(note, octave, volume, duration = 1) {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      const noteIdx = NOTES.indexOf(note);
      const frequency = 440 * Math.pow(2, (octave * 12 + noteIdx - 57)/12);
      oscillator.type = "sine";
      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
      gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + duration);
    }

    function getPitchShiftedNote(note, octave) {
      const standardNote = standardizeNoteName(note);
      const nearest = findNearestSampledNote(standardNote, octave);
      if (nearest) {
        return { sampleKey: nearest.sampleKey, playbackRate: Math.pow(2, nearest.semitoneDiff / 12) };
      }
      return null;
    }

    function findNearestSampledNote(note, octave) {
      let minDistance = Infinity, nearestNote = null, nearestOctave = octave;
      const noteIndex = NOTES.indexOf(note);
      const SAMPLED_NOTES = ['A','C','Ds','Fs'];
      for (let sampledNote of SAMPLED_NOTES) {
        const compareNote = sampledNote === 'Fs' ? 'F#' : sampledNote === 'Ds' ? 'D#' : sampledNote;
        const sampledIndex = NOTES.indexOf(standardizeNoteName(compareNote));
        const distance = Math.abs(noteIndex - sampledIndex);
        if (distance < minDistance) {
          minDistance = distance;
          nearestNote = sampledNote;
          if (noteIndex < sampledIndex && noteIndex < 3 && sampledIndex > 8) {
            nearestOctave = octave - 1;
          } else if (noteIndex > sampledIndex && noteIndex > 8 && sampledIndex < 3) {
            nearestOctave = octave + 1;
          }
        }
      }
      return { sampleKey: `${nearestNote}${nearestOctave}v12`, semitoneDiff: (noteIndex - NOTES.indexOf(standardizeNoteName(nearestNote === 'Fs' ? 'F#' : nearestNote)) + 12) % 12 };
    }

    function playChord(root, quality, time = audioContext.currentTime, duration = 1) {
      if (!audioContext || !document.getElementById("chordsEnabled").checked) return;
      if (!reverbNode) setupReverb();
      const chordVolume = parseFloat(document.getElementById("chord-volume").value) || 0.5;
      if (currentChordGain) {
        currentChordGain.gain.setValueAtTime(currentChordGain.gain.value, time);
        currentChordGain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
      }
      const mainGainNode = audioContext.createGain();
      const dryGainNode = audioContext.createGain();
      const wetGainNode = audioContext.createGain();
      dryGainNode.gain.value = 0.7;
      wetGainNode.gain.value = 0.3;
      mainGainNode.connect(dryGainNode);
      mainGainNode.connect(wetGainNode);
      dryGainNode.connect(audioContext.destination);
      wetGainNode.connect(reverbNode);
      currentChordGain = mainGainNode;
      const rootIndex = NOTES.indexOf(root);
      let chordNotes = [root];
      const thirdIndex = (rootIndex + (quality.includes("minor") ? 3 : 4)) % 12;
      chordNotes.push(NOTES[thirdIndex]);
      const fifthIndex = (rootIndex + 7) % 12;
      chordNotes.push(NOTES[fifthIndex]);
      if (quality.includes("7")) {
        const seventhIndex = (rootIndex + (quality.includes("maj7") ? 11 : 10)) % 12;
        chordNotes.push(NOTES[seventhIndex]);
      }
      if (quality === "min7b5") {
        chordNotes[2] = NOTES[(rootIndex + 6) % 12];
      }
      const attackTime = 0.08, decayTime = 0.15, sustainLevel = 0.7, releaseTime = 0.4;
      if (samplesLoaded && pianoSampleBuffers) {
        chordNotes.forEach((note, index) => {
          const noteOctave = 3 + (index === 0 ? -1 : 0);
          const pitchData = getPitchShiftedNote(note, noteOctave);
          if (pitchData && pianoSampleBuffers[pitchData.sampleKey]) {
            const source = audioContext.createBufferSource();
            const noteGain = audioContext.createGain();
            source.buffer = pianoSampleBuffers[pitchData.sampleKey];
            source.playbackRate.value = pitchData.playbackRate;
            noteGain.gain.setValueAtTime(0, time);
            noteGain.gain.linearRampToValueAtTime(chordVolume * 0.25, time + attackTime);
            noteGain.gain.linearRampToValueAtTime(chordVolume * 0.25 * sustainLevel, time + attackTime + decayTime);
            noteGain.gain.setValueAtTime(chordVolume * 0.25 * sustainLevel, time + duration - releaseTime);
            noteGain.gain.exponentialRampToValueAtTime(0.001, time + duration);
            source.connect(noteGain);
            noteGain.connect(mainGainNode);
            source.start(time);
            source.stop(time + duration);
          } else {
            playFallbackChordNote(note, noteOctave, chordVolume * 0.25, time, duration, mainGainNode);
          }
        });
      } else {
        chordNotes.forEach((note, index) => {
          const noteOctave = 3 + (index === 0 ? -1 : 0);
          playFallbackChordNote(note, noteOctave, chordVolume * 0.25, time, duration, mainGainNode);
        });
      }
    }

    function playFallbackChordNote(note, octave, volume, time, duration, outputNode) {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      const noteIndex = NOTES.indexOf(note);
      const frequency = 440 * Math.pow(2, (octave * 12 + noteIndex - 57) / 12);
      oscillator.type = "triangle";
      oscillator.frequency.setValueAtTime(frequency, time);
      const attackTime = 0.08, decayTime = 0.15, sustainLevel = 0.7, releaseTime = 0.4;
      gainNode.gain.setValueAtTime(0, time);
      gainNode.gain.linearRampToValueAtTime(volume, time + attackTime);
      gainNode.gain.linearRampToValueAtTime(volume * sustainLevel, time + attackTime + decayTime);
      gainNode.gain.setValueAtTime(volume * sustainLevel, time + duration - releaseTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, time + duration);
      oscillator.connect(gainNode);
      gainNode.connect(outputNode);
      oscillator.start(time);
      oscillator.stop(time + duration);
    }

    function parseChord(chord) {
      const rootMatch = chord.match(/^[A-G]#?/);
      const root = rootMatch ? rootMatch[0] : "C";
      const quality = chord.replace(root, "");
      return [root, quality || "major"];
    }

    function mapQualityToDropdown(quality) {
      switch (quality) {
        case "7":
          return "dom7";
        case "m7":
          return "min7";
        case "maj7":
          return "maj7";
        case "m":
          return "minor";
        case "":
          return "major";
        case "min7b5":
          return "min7b5";
        default:
          return "major";
      }
    }

    function suggestScaleForQuality(quality) {
      switch (quality) {
        case "7":
          return "mixolydian";
        case "m7":
          return "dorian";
        case "maj7":
          return "major";
        case "m":
          return "minor";
        case "min7b5":
          return "locrian";
        default:
          return "major";
      }
    }

    function addFirstChordListener() {
      const measures = document.getElementsByClassName("measure");
      if (measures.length === 0) return;
      const firstMeasure = measures[0];
      const firstRootSelect = firstMeasure.querySelector(".root-note");
      if (!firstRootSelect) return;
      firstRootSelect.removeEventListener("change", firstChordChangeHandler);
      firstRootSelect.addEventListener("change", firstChordChangeHandler);
    }

    function firstChordChangeHandler() {
      const newKey = this.value;
      updateProgressionKey(newKey);
    }

    function updateProgressionKey(newKey) {
      const measures = document.getElementsByClassName("measure");
      if (measures.length <= 1) return;
      const selectedProgression = document.getElementById("progression-select").value;
      if (selectedProgression === "none") return;
      const progressionChords = progressions[selectedProgression].progression;
      if (!progressionChords) return;
      Array.from(measures).forEach((measure, index) => {
        const chordFunc = progressionChords[index];
        if (!chordFunc) return;
        const newChord = getChordFromFunction(newKey, chordFunc);
        const [root, quality] = parseChord(newChord);
        const rootNoteSelect = measure.querySelector(".root-note");
        const qualitySelect = measure.querySelector(".chord-quality");
        const secondKeySelect = measure.querySelector(".second-key");
        const scaleSelect = measure.querySelector(".scale-select");
        rootNoteSelect.value = root;
        qualitySelect.value = mapQualityToDropdown(quality);
        secondKeySelect.value = root;
        scaleSelect.value = suggestScaleForQuality(quality);
      });
      const chordFretboard = document.getElementById("chord-fretboard");
      if (chordFretboard) {
        const tuning = TUNINGS[document.getElementById("chord-tuning").value] || TUNINGS.standard;
        const firstMeasure = measures[0];
        const scaleType = firstMeasure.querySelector(".scale-select").value;
        updateFretboardNotes(chordFretboard, newKey, scaleType, tuning);
      }
    }

    // Get chord from Roman numeral function (simplified for our purposes)
    function getChordFromFunction(key, func) {
    // Handle empty or invalid inputs
    if (!key || !func) return "C";

    // Standardize the key name and handle minor keys
    const isMinorKey = key.toLowerCase().includes("m");
    const rootKey = standardizeNoteName(key.replace(/m$/, ""));
    const keyIndex = NOTES.indexOf(rootKey);

    // Complete mapping of all possible scale degrees and their intervals
    const scaleDegrees = {
        // Major scale degrees (uppercase numerals)
        'I': 0, 'II': 2, 'III': 4, 'IV': 5, 'V': 7, 'VI': 9, 'VII': 11,
        // Minor scale degrees (lowercase numerals)
        'i': 0, 'ii': 2, 'iii': 3, 'iv': 5, 'v': 7, 'vi': 8, 'vii': 10,
        // Dominant seventh chords
        'I7': 0, 'II7': 2, 'III7': 4, 'IV7': 5, 'V7': 7, 'VI7': 9, 'VII7': 11,
        // Minor seventh chords
        'i7': 0, 'ii7': 2, 'iii7': 3, 'iv7': 5, 'v7': 7, 'vi7': 8, 'vii7': 10,
        // Major seventh chords
        'Imaj7': 0, 'IImaj7': 2, 'IIImaj7': 4, 'IVmaj7': 5, 'Vmaj7': 7, 'VImaj7': 9, 'VIImaj7': 11,
        // Half-diminished chords
        'iim7b5': 2, 'iiim7b5': 3, 'vim7b5': 8, 'viim7b5': 10,
        // Additional common jazz notation
        'bII': 1, 'bIII': 3, 'bV': 6, 'bVI': 8, 'bVII': 10,
        'bII7': 1, 'bIII7': 3, 'bV7': 6, 'bVI7': 8, 'bVII7': 10
    };

    // Get the interval for the scale degree
    const degree = scaleDegrees[func];
    if (degree === undefined) return key; // Return original key if function not found

    // Calculate the root note of the chord
    const note = NOTES[(keyIndex + degree) % 12];

    // Determine chord quality based on function and context
    let quality = "";
    
    // Handle seventh chords first
    if (func.includes('maj7')) {
        quality = "maj7";
    } else if (func.includes('m7b5')) {
        quality = "min7b5";
    } else if (func.includes('7')) {
        if (func === 'V7' || func.startsWith('V7/') || func.match(/[A-Z]7/)) {
            quality = "7"; // Dominant seventh
        } else {
            quality = func.match(/[A-Z]/) ? "maj7" : "m7";
        }
    } else {
        // Handle triads
        if (isMinorKey) {
            // In minor keys, handle natural minor scale qualities
            const minorScaleDegrees = ['i', 'ii', 'III', 'iv', 'v', 'VI', 'VII'];
            quality = func.match(/[A-Z]/) ? "" : "m";
        } else {
            // In major keys, handle major scale qualities
            const majorScaleDegrees = ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii°'];
            quality = func.match(/[A-Z]/) ? "" : "m";
        }
    }

    // Special handling for diminished chords
    if (func.includes('°')) {
        quality = "dim";
    }

    // Handle secondary dominants (e.g., V7/V)
    if (func.includes('/')) {
        const [primaryFunc, secondaryFunc] = func.split('/');
        const secondaryRoot = getChordFromFunction(key, secondaryFunc).split(/[^A-Gb]+/)[0];
        return getChordFromFunction(secondaryRoot, primaryFunc);
    }

    // Return the complete chord name
    return note + quality;
}
    function createBeats() {
      const container = document.querySelector(".beats-container");
      container.innerHTML = "";
      const timeSignature = parseInt(document.getElementById("time-signature").value);
      const BEAT_STATES = [
        { volume: "1", color: "#1F618D", sound: "default" },
        { volume: "1", color: "#BD2031", sound: "kick" },
        { volume: "0.5", color: "#8B0000", sound: "kick" },
        { volume: "1", color: "#006400", sound: "snare" },
        { volume: "0.5", color: "#004200", sound: "snare" },
        { volume: "1", color: "#4CAF50", sound: "hihat" },
        { volume: "0", color: "#9E9E9E", sound: "silent" }
      ];
      const totalBeats = timeSignature === 4 ? 8 : timeSignature;
      for (let i = 0; i < totalBeats; i++) {
        const beat = document.createElement("div");
        beat.className = "beat";
        beat.dataset.beat = i;
        if (timeSignature === 4) {
          const isEighth = i % 2 === 1;
          beat.innerHTML = `${Math.floor(i / 2 + 1)}${isEighth ? "&" : ""}`;
          if (i === 0 || i === 4) {
            beat.dataset.volume = "1";
            beat.dataset.sound = "kick";
            beat.style.backgroundColor = "#BD2031";
          } else if (i === 2 || i === 6) {
            beat.dataset.volume = "1";
            beat.dataset.sound = "snare";
            beat.style.backgroundColor = "#006400";
          } else {
            beat.dataset.volume = "0.7";
            beat.dataset.sound = "hihat";
            beat.style.backgroundColor = "#4CAF50";
          }
        } else {
          beat.innerHTML = i + 1;
          beat.dataset.volume = i === 0 ? "1" : "0.3";
          beat.dataset.sound = "default";
          beat.style.backgroundColor = i === 0 ? "#1F618D" : "#4CAF50";
        }
        beat.addEventListener("click", function () {
          const currentState = { volume: this.dataset.volume, color: this.style.backgroundColor, sound: this.dataset.sound };
          let nextStateIndex = 0;
          const currentStateIndex = BEAT_STATES.findIndex(state => state.volume === currentState.volume && state.sound === currentState.sound);
          if (currentStateIndex !== -1) {
            nextStateIndex = (currentStateIndex + 1) % BEAT_STATES.length;
          }
          const nextState = BEAT_STATES[nextStateIndex];
          this.dataset.volume = nextState.volume;
          this.dataset.sound = nextState.sound;
          this.style.backgroundColor = nextState.color;
        });
        container.appendChild(beat);
      }
    }

    function createFretboard(container, tuning) {
      container.innerHTML = "";
      const markersContainer = document.createElement("div");
      markersContainer.style.position = "absolute";
      markersContainer.style.width = "100%";
      markersContainer.style.height = "100%";
      markersContainer.style.pointerEvents = "none";
      container.appendChild(markersContainer);
      [3, 5, 7, 9, 12].forEach(fret => {
        const marker = document.createElement("div");
        marker.className = "fret-marker";
        marker.style.position = "absolute";
        marker.style.width = "12px";
        marker.style.height = "12px";
        marker.style.backgroundColor = "#333";
        marker.style.borderRadius = "50%";
        marker.style.left = `${((fret - 0.5) / 12) * 100}%`;
        marker.style.top = "50%";
        marker.style.transform = "translate(-50%, -50%)";
        if (fret === 12) {
          const marker1 = marker.cloneNode();
          marker1.style.top = "40%";
          markersContainer.appendChild(marker1);
          const marker2 = marker.cloneNode();
          marker2.style.top = "60%";
          markersContainer.appendChild(marker2);
        } else {
          markersContainer.appendChild(marker);
        }
      });
      for (let i = 0; i <= 12; i++) {
        const fretLine = document.createElement("div");
        fretLine.className = "fret-line";
        fretLine.style.left = `${(i / 12) * 100}%`;
        container.appendChild(fretLine);
        if ([3,5,7,9,12].includes(i)) {
          const fretNumber = document.createElement("div");
          fretNumber.className = "fret-number";
          fretNumber.textContent = i;
          fretNumber.style.left = `${(i / 12) * 100}%`;
          container.appendChild(fretNumber);
        }
      }
      for (let i = 0; i < 6; i++) {
        const stringLine = document.createElement("div");
        stringLine.className = "string-line";
        stringLine.style.top = `${(i / 5) * 100}%`;
        container.appendChild(stringLine);
      }
    }

    function updateFretboardNotes(container, rootNote, scale, tuning) {
      container.querySelectorAll(".note").forEach(note => note.remove());
      if (container.id === "chord-fretboard") {
        const measures = document.getElementsByClassName("measure");
        if (measures.length > 0 && currentMeasure < measures.length) {
          const currentMeasureElement = measures[currentMeasure];
          const chordRoot = currentMeasureElement.querySelector(".chord-controls .root-note")?.value;
          const chordQuality = currentMeasureElement.querySelector(".chord-controls .chord-quality")?.value;
          const scaleRoot = currentMeasureElement.querySelector(".scale-controls .second-key")?.value;
          const scaleType = currentMeasureElement.querySelector(".scale-controls .scale-select")?.value;
          if (chordRoot && chordQuality && scaleRoot && scaleType) {
            document.getElementById("scale-display").textContent = `${scaleRoot} ${scaleType} over ${chordRoot} ${chordQuality}`;
          }
        }
      }
      const scaleIntervals = window.SCALES ? window.SCALES[scale] : [0,2,4,5,7,9,11];
      const scaleNotes = scaleIntervals.map(interval => NOTES[(NOTES.indexOf(rootNote) + interval) % 12]);
      for (let string = 0; string < 6; string++) {
        const openNote = tuning[string];
        const openNoteIndex = NOTES.indexOf(openNote);
        for (let fret = 0; fret <= 12; fret++) {
          const noteIndex = (openNoteIndex + fret) % 12;
          const currentNote = NOTES[noteIndex];
          if (scaleNotes.includes(currentNote)) {
            const noteElement = document.createElement("div");
            noteElement.className = "note";
            noteElement.textContent = currentNote;
            const fretOffset = fret === 0 ? 0 : ((fret - 0.5) / 12) * 100;
            noteElement.style.left = `${fretOffset}%`;
            noteElement.style.top = `${(string / 5) * 100}%`;
            const degree = scaleNotes.indexOf(currentNote);
            if (currentNote === rootNote) noteElement.style.backgroundColor = "#BD2031";
            else if ([2, 4, 6].includes(degree)) noteElement.style.backgroundColor = "#006400";
            else noteElement.style.backgroundColor = "#4CAF50";
            noteElement.addEventListener("click", () => playNote(currentNote, string, fret));
            container.appendChild(noteElement);
          }
        }
      }
    }

    function createFretboardContainer(index) {
      const container = document.createElement("div");
      container.className = "fretboard-container";
      container.innerHTML = `
        <div class="scale-display" id="scale-display-${index}">C major</div>
        <div class="controls">
          <select class="tuning-select">
            <option value="standard">Standard (EADGBE)</option>
            <option value="dropD">Drop D (DADGBE)</option>
            <option value="openG">Open G (DGDGBD)</option>
            <option value="DADGAD">DADGAD</option>
            <option value="openE">Open E (EBEG#BE)</option>
          </select>
          <select class="keySelect" id="key-${index}">
            ${["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"].map(note => `<option value="${note}">${note}</option>`).join('')}
          </select>
          <select class="scale-select" id="scale-${index}">
            ${Object.keys(window.SCALES || {"major":""}).map(scale => `<option value="${scale}">${scale}</option>`).join('')}
          </select>
        </div>
        <div class="fretboard" id="fretboard-${index}"></div>
      `;
      return container;
    }

    function initializeStaticFretboards() {
      const grid = document.querySelector(".fretboards-grid");
      grid.innerHTML = "";
      for (let i = 1; i <= 4; i++) {
        const container = createFretboardContainer(i);
        grid.appendChild(container);
        const fretboard = container.querySelector(".fretboard");
        createFretboard(fretboard, TUNINGS.standard);
        updateFretboardNotes(fretboard, "C", "major", TUNINGS.standard);
        container.querySelector(".tuning-select").addEventListener("change", function () {
          const tuning = TUNINGS[this.value];
          const key = container.querySelector(`#key-${i}`).value;
          const scale = container.querySelector(`#scale-${i}`).value;
          updateFretboardNotes(fretboard, key, scale, tuning);
        });
        container.querySelector(`#key-${i}`).addEventListener("change", function () {
          const tuning = TUNINGS[container.querySelector(".tuning-select").value];
          const scale = container.querySelector(`#scale-${i}`).value;
          updateFretboardNotes(fretboard, this.value, scale, tuning);
        });
        container.querySelector(`#scale-${i}`).addEventListener("change", function () {
          const tuning = TUNINGS[container.querySelector(".tuning-select").value];
          const key = container.querySelector(`#key-${i}`).value;
          updateFretboardNotes(fretboard, key, this.value, tuning);
        });
      }
    }

    function dragStart(e) {
      e.dataTransfer.setData("text/plain", Array.from(document.querySelectorAll(".measure")).indexOf(this));
      this.classList.add("dragging");
    }
    function dragOver(e) { e.preventDefault(); }
    function drop(e) {
      e.preventDefault();
      const fromIndex = parseInt(e.dataTransfer.getData("text/plain"));
      const toIndex = Array.from(document.querySelectorAll(".measure")).indexOf(this);
      const measures = document.getElementById("measures");
      const children = Array.from(measures.children);
      const [movedMeasure] = children.splice(fromIndex, 1);
      children.splice(toIndex, 0, movedMeasure);
      measures.innerHTML = "";
      children.forEach(child => measures.appendChild(child));
    }
    function dragEnd(e) { this.classList.remove("dragging"); }

    function loadProgression(progressionKey) {
    const progressionDef = progressions[progressionKey];
    if (!progressionDef) return;

    const measuresDiv = document.getElementById("measures");
    measuresDiv.innerHTML = "";

    const defaultKey = progressionDef.defaultKey;
    document.getElementById("keySelect").value = defaultKey.replace(/m$/, "");

    // Initialize first measure flag
    let isFirstMeasure = true;

    progressionDef.progression.forEach((chordFunc, index) => {
        const chord = getChordFromFunction(defaultKey, chordFunc);
        const [root, quality] = parseChord(chord);

        const newMeasure = document.createElement("div");
        newMeasure.className = "measure";
        newMeasure.draggable = true;

        // Set active class if it's the first measure
        if (isFirstMeasure) {
            newMeasure.classList.add("active");
            isFirstMeasure = false;
        }

        // Map chord qualities to dropdown values
        const qualityToDropdown = {
            "": "major",
            "m": "minor",
            "7": "dom7",
            "maj7": "maj7",
            "m7": "min7",
            "min7b5": "min7b5",
            "dim": "dim"
        };

        // Create measure HTML with proper chord values
        newMeasure.innerHTML = `
            <span class="measure-number">${index + 1}</span>
            <div class="chord-controls">
                <select class="root-note">
                    ${NOTES.map(note => `<option value="${note}" ${note === root ? "selected" : ""}>${note}</option>`).join("")}
                </select>
                <select class="chord-quality">
                    <option value="major" ${quality === "" ? "selected" : ""}>Major</option>
                    <option value="minor" ${quality === "m" ? "selected" : ""}>Minor</option>
                    <option value="dom7" ${quality === "7" ? "selected" : ""}>7</option>
                    <option value="maj7" ${quality === "maj7" ? "selected" : ""}>Maj7</option>
                    <option value="min7" ${quality === "m7" ? "selected" : ""}>Min7</option>
                    <option value="min7b5" ${quality === "min7b5" ? "selected" : ""}>Min7b5 (Half Diminished)</option>
                    <option value="dim" ${quality === "dim" ? "selected" : ""}>Diminished</option>
                </select>
            </div>
            <div class="scale-controls">
                <select class="second-key">
                    ${NOTES.map(note => `<option value="${note}" ${note === root ? "selected" : ""}>${note}</option>`).join("")}
                </select>
                <select class="scale-select">
                    ${Object.keys(window.SCALES || {
                        "major": "",
                        "minor": "",
                        "dorian": "",
                        "mixolydian": "",
                        "locrian": ""
                    }).map(scale => {
                        const suggested = suggestScaleForQuality(qualityToDropdown[quality] || "major");
                        return `<option value="${scale}" ${scale === suggested ? "selected" : ""}>${scale}</option>`;
                    }).join("")}
                </select>
            </div>
        `;

        // Add drag and drop event listeners
        newMeasure.addEventListener("dragstart", dragStart);
        newMeasure.addEventListener("dragover", dragOver);
        newMeasure.addEventListener("drop", drop);
        newMeasure.addEventListener("dragend", dragEnd);

        // Add change event listeners for the selects
        const rootNoteSelect = newMeasure.querySelector(".root-note");
        const qualitySelect = newMeasure.querySelector(".chord-quality");
        const secondKeySelect = newMeasure.querySelector(".second-key");
        const scaleSelect = newMeasure.querySelector(".scale-select");

        // Update chord and scale when selections change
        rootNoteSelect.addEventListener("change", function() {
            secondKeySelect.value = this.value;
            updateChordProgression();
        });

        qualitySelect.addEventListener("change", function() {
            scaleSelect.value = suggestScaleForQuality(this.value);
            updateChordProgression();
        });

        // Add the measure to the measures div
        measuresDiv.appendChild(newMeasure);
    });

    // Update measure numbers and add first chord listener
    updateMeasureNumbers();
    addFirstChordListener();

    // Update the chord fretboard display
    const firstMeasure = document.querySelector(".measure");
    if (firstMeasure) {
        const root = firstMeasure.querySelector(".root-note").value;
        const quality = firstMeasure.querySelector(".chord-quality").value;
        const scaleRoot = firstMeasure.querySelector(".second-key").value;
        const scaleType = firstMeasure.querySelector(".scale-select").value;
        
        const chordFretboard = document.getElementById("chord-fretboard");
        if (chordFretboard) {
            const tuning = TUNINGS[document.getElementById("chord-tuning").value] || TUNINGS.standard;
            updateFretboardNotes(chordFretboard, scaleRoot, scaleType, tuning);
        }
    }

    // Trigger an initial chord progression update
    updateChordProgression();
}
    
    function addMeasure() {
      const measuresDiv = document.getElementById("measures");
      const newMeasure = document.createElement("div");
      newMeasure.className = "measure";
      newMeasure.draggable = true;
      newMeasure.innerHTML = `
        <span class="measure-number">${measuresDiv.children.length + 1}</span>
        <div class="chord-controls">
          <select class="root-note">
            ${NOTES.map(note => `<option>${note}</option>`).join("")}
          </select>
          <select class="chord-quality">
            <option value="major">Major</option>
            <option value="minor">Minor</option>
            <option value="dom7">7</option>
            <option value="maj7">Maj7</option>
            <option value="min7">Min7</option>
            <option value="min7b5">Min7b5 (Half Diminished)</option>
          </select>
        </div>
        <div class="scale-controls">
          <select class="second-key">
            ${NOTES.map(note => `<option>${note}</option>`).join("")}
          </select>
          <select class="scale-select">
            ${Object.keys(window.SCALES || {"major":""}).map(scale => `<option value="${scale}">${scale.charAt(0).toUpperCase() + scale.slice(1)}</option>`).join("")}
          </select>
        </div>
      `;
      newMeasure.addEventListener("dragstart", dragStart);
      newMeasure.addEventListener("dragover", dragOver);
      newMeasure.addEventListener("drop", drop);
      newMeasure.addEventListener("dragend", dragEnd);
      measuresDiv.appendChild(newMeasure);
      updateMeasureNumbers();
      if (measuresDiv.children.length === 1) addFirstChordListener();
    }

    function removeMeasure() {
      const measures = document.getElementById("measures");
      if (measures.children.length > 1) {
        measures.removeChild(measures.lastChild);
        updateMeasureNumbers();
      }
    }

    function updateMeasureNumbers() {
      const measures = document.getElementsByClassName("measure");
      Array.from(measures).forEach((measure, index) => {
        measure.querySelector(".measure-number").textContent = index + 1;
      });
    }

    function startPlayback() {
      if (!audioContext) initAudioContext();
      if (isPlaying) return;
      const timeSignature = parseInt(document.getElementById("time-signature").value);
      const measures = document.getElementsByClassName("measure");
      if (measures.length === 0) return;
      let interval = (60 / tempo) * 1000;
      if (timeSignature === 4) interval = interval / 2;
      currentBeat = 0;
      currentMeasure = 0;
      clearInterval(intervalId);
      const currentMeasureElement = measures[currentMeasure];
      if (currentMeasureElement) {
        const root = currentMeasureElement.querySelector(".chord-controls .root-note")?.value;
        const quality = currentMeasureElement.querySelector(".chord-controls .chord-quality")?.value;
        const scaleRoot = currentMeasureElement.querySelector(".scale-controls .second-key")?.value;
        const scaleType = currentMeasureElement.querySelector(".scale-controls .scale-select")?.value;
        if (root && quality && scaleRoot && scaleType) {
          const chordTuning = TUNINGS[document.getElementById("chord-tuning").value];
          updateFretboardNotes(document.getElementById("chord-fretboard"), scaleRoot, scaleType, chordTuning);
          playChord(root, quality);
        }
      }
      intervalId = setInterval(async () => {
        await playBeat();
      }, interval);
      isPlaying = true;
      document.getElementById("start-stop").textContent = "Stop";
    }

    async function playBeat() {
      const beats = document.querySelectorAll(".beat");
      beats.forEach(beat => beat.classList.remove("active"));
      const currentBeatElement = beats[currentBeat];
      if (currentBeatElement) {
        currentBeatElement.classList.add("active");
        const volume = parseFloat(currentBeatElement.dataset.volume) || 0;
        await playMetronomeSound(volume);
      }
      const measures = document.getElementsByClassName("measure");
      const timeSignature = parseInt(document.getElementById("time-signature").value);
      if (measures.length > 0) {
        const currentMeasureElement = measures[currentMeasure];
        if (currentMeasureElement) {
          const root = currentMeasureElement.querySelector(".chord-controls .root-note")?.value;
          const quality = currentMeasureElement.querySelector(".chord-controls .chord-quality")?.value;
          const scaleRoot = currentMeasureElement.querySelector(".scale-controls .second-key")?.value;
          const scaleType = currentMeasureElement.querySelector(".scale-controls .scale-select")?.value;
          if (root && quality && scaleRoot && scaleType) {
            const chordTuning = TUNINGS[document.getElementById("chord-tuning").value];
            updateFretboardNotes(document.getElementById("chord-fretboard"), scaleRoot, scaleType, chordTuning);
            const beatDuration = 60 / tempo;
            if (timeSignature === 4) {
              if (currentBeat === 0) playChord(root, quality, audioContext.currentTime, beatDuration * 2);
              else if (currentBeat === 4) playChord(root, quality, audioContext.currentTime, beatDuration * 2);
            } else if (currentBeat === 0) playChord(root, quality, audioContext.currentTime, beatDuration * 4);
          }
        }
      }
      document.querySelectorAll(".measure").forEach((measure, index) => {
        measure.classList.toggle("active", index === currentMeasure);
      });
      const totalBeats = timeSignature === 4 ? 8 : timeSignature;
      currentBeat = (currentBeat + 1) % totalBeats;
      if (currentBeat === 0 && measures.length > 0) {
        currentMeasure = (currentMeasure + 1) % measures.length;
      }
    }

    function stopPlayback() {
      clearInterval(intervalId);
      intervalId = null;
      isPlaying = false;
      currentBeat = 0;
      currentMeasure = 0;
      document.querySelectorAll(".beat").forEach(beat => beat.classList.remove("active"));
      document.querySelectorAll(".measure").forEach(measure => measure.classList.remove("active"));
      if (currentChordGain) {
        currentChordGain.gain.setValueAtTime(currentChordGain.gain.value, audioContext.currentTime);
        currentChordGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
        currentChordGain = null;
      }
      document.getElementById("start-stop").textContent = "Start";
    }

    document.getElementById("start-stop").addEventListener("click", function () {
      if (!audioContext) initAudioContext();
      if (isPlaying) stopPlayback();
      else startPlayback();
    });

    document.getElementById("tempo").addEventListener("input", function () {
      tempo = parseInt(this.value);
      document.getElementById("tempo-display").textContent = `${tempo} BPM`;
      if (isPlaying) { stopPlayback(); startPlayback(); }
    });

    document.getElementById("time-signature").addEventListener("change", function () {
      createBeats();
      if (isPlaying) { stopPlayback(); startPlayback(); }
    });

    document.getElementById("tap-tempo").addEventListener("click", function () {
      const now = Date.now();
      if (now - lastTapTime > 2000) tapTimes = [];
      tapTimes.push(now);
      lastTapTime = now;
      if (tapTimes.length > 1) {
        const intervals = [];
        for (let i = 1; i < tapTimes.length; i++) {
          intervals.push(tapTimes[i] - tapTimes[i - 1]);
        }
        const averageInterval = intervals.reduce((a, b) => a + b) / intervals.length;
        tempo = Math.round(60000 / averageInterval);
        tempo = Math.min(Math.max(tempo, 40), 220);
        document.getElementById("tempo").value = tempo;
        document.getElementById("tempo-display").textContent = `${tempo} BPM`;
        if (isPlaying) { stopPlayback(); startPlayback(); }
      }
    });

    document.getElementById("metronome-volume").addEventListener("input", function () {
      if (isPlaying) { stopPlayback(); startPlayback(); }
    });

    document.addEventListener("DOMContentLoaded", function () {
      createBeats();
      initializeStaticFretboards();
      // Set the default value in the select element
    const progressionSelect = document.getElementById("progression-select");
    progressionSelect.value = "iv";
    
    // Load the I-V progression
    loadProgression("iv");
    addFirstChordListener();
    // ... rest of the initialization code ...
      addFirstChordListener();
      document.getElementById("keySelect").innerHTML = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"].map(n => `<option value="${n}">${n}</option>`).join("");
      document.querySelectorAll(".root-note, .second-key").forEach(select => {
        select.innerHTML = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"].map(n => `<option value="${n}">${n}</option>`).join("");
      });
      document.querySelectorAll(".fretboards-grid .keySelect").forEach(select => {
        select.innerHTML = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"].map(n => `<option value="${n}">${n}</option>`).join("");
      });
      const chordFretboard = document.getElementById("chord-fretboard");
      if (chordFretboard) {
        createFretboard(chordFretboard, TUNINGS.standard);
        updateFretboardNotes(chordFretboard, "C", "major", TUNINGS.standard);
      }
      initializeAudio().then(() => console.log("Audio context initialized")).catch(error => console.error("Audio init error:", error));
    });

    window.onload = function () {
      const chordFretboard = document.getElementById("chord-fretboard");
      if (chordFretboard) {
        createFretboard(chordFretboard, TUNINGS.standard);
        updateFretboardNotes(chordFretboard, "C", "major", TUNINGS.standard);
      }
    };
  </script>
</body>
</html>
