<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="es335icon.png">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Lato', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1f618d;
        }
        .app-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .fretboards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        .fretboard-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .scale-display {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            color: #333;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .fretboard {
            position: relative;
            height: 200px;
            background-color: #FFCF79;
            border-radius: 5px;
            margin-bottom: 30px;
            border: 2px solid #4B1C2E;
            overflow: visible;
        }
        .fret-line {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: #c0c0c0;
            border-right: 1px solid rgba(0, 0, 0, 0.3);
            z-index: 1;
        }
        .string-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 1px;
            background: silver;
            border-bottom: 1px solid rgba(0, 0, 0, 0.3);
            z-index: 0;
        }
        .fret-number {
            position: absolute;
            bottom: -40px;
            font-size: 16px;
            color: #1f618d;
            transform: translateX(-50%);
            font-weight: bold;
            z-index: 2;
            width: 20px;
            text-align: center;
        }
        .fret-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #333;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .note {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            z-index: 3;
            cursor: pointer;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease;
        }
        .note:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }
        .beat {
            width: 40px;
            height: 80px;
            background: #9E9E9E;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: all 0.2s ease;
            font-size: 14px;
            margin: 0 2px;
        }
        .beats-container {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
            flex-wrap: nowrap;
        }
        .beat.active {
            transform: translateY(-10px);
        }
        #measures {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
        }
        .measure {
            position: relative;
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            transition: opacity 0.2s ease;
        }
        .measure.dragging {
            opacity: 0.5;
        }
        .measure.active {
            background-color: #c3e6cb;
            border: 2px solid #28a745;
        }
        .measure-number {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 12px;
            color: #333;
        }
        .chord-controls, .scale-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .chord-controls select, .scale-controls select {
            flex: 1;
        }
        @media (max-width: 1200px) {
            #measures {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (max-width: 600px) {
            #measures {
                grid-template-columns: 1fr;
            }
        }
        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }
        select {
            padding: 5px;
            margin: 5px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        #tempo-display {
            font-size: 1.2em;
            font-weight: bold;
            margin: 0 10px;
        }
        #loading-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            border-radius: 5px;
            z-index: 1000;
        }
        body.dark-mode {
            background-color: #283618;
            color: #fefae0;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .dark-mode .app-section {
            background: linear-gradient(145deg, #283618, #606c38);
            color: #fefae0;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .dark-mode .fretboard-container {
            background-color: #606c38;
            border: 1px solid #dda15e;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .dark-mode .fretboard {
            background-color: #dda15e;
            border: 2px solid #4b4b4b;
            border-radius: 5px;
        }
        .dark-mode .note {
            background-color: #dda15e;
            color: #283618;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .dark-mode .note:hover {
            transform: scale(1.2);
            background-color: #bc6c25;
        }
        .dark-mode .scale-display {
            color: #fefae0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        .dark-mode button {
            background-color: #dda15e;
            color: #283618;
            border: 1px solid #bc6c25;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .dark-mode button:hover {
            background-color: #bc6c25;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        .dark-mode select {
            background-color: #dda15e;
            color: #283618;
            border: 1px solid #bc6c25;
        }
        .dark-mode select:hover {
            background-color: #bc6c25;
        }
        .dark-mode .measure {
            background-color: #606c38;
            color: #fefae0;
            border: 1px solid #dda15e;
        }
        .dark-mode .measure.active {
            background-color: #dda15e;
            border-color: #bc6c25;
        }
        .dark-mode .beat {
            background-color: #dda15e;
            color: #283618;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .dark-mode .beat.active {
            background-color: #bc6c25;
            transform: translateY(-5px);
        }
        .dark-mode .volume-control {
            color: #fefae0;
        }
        .dark-mode .volume-control input[type="range"] {
            background: #606c38;
        }
        .dark-mode .volume-control input[type="range"]::-webkit-slider-thumb {
            background: #dda15e;
            border: 1px solid #bc6c25;
        }
        #dark-mode-toggle.active {
            background-color: #283618;
            color: #fefae0;
            border: 1px solid #dda15e;
        }
    </style>
</head>
<body>
    <div class="app-section" id="chord-fretboard-section">
        <h1>BEBOP BLUEPRINT</h1>
        <h3>Fretflow - Dynamic Fretboard with Scales that Move with the Chord Progression</h3>
        <button id="dark-mode-toggle" aria-label="Toggle dark mode">Dark Mode</button>
        <div class="volume-control">
            <span>Fretboard Volume:</span>
            <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.1" value="0.3">
        </div>
        <div class="fretboard-container">
            <div class="scale-display" id="scale-display"></div>
            <div class="controls">
                <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
                    <option value="standard">Standard (EADGBE)</option>
                    <option value="dropD">Drop D (DADGBE)</option>
                    <option value="openG">Open G (DGDGBD)</option>
                    <option value="DADGAD">DADGAD</option>
                    <option value="openE">Open E (EBEG#BE)</option>
                </select>
            </div>
            <div id="chord-fretboard" class="fretboard"></div>
        </div>
    </div>

    <div class="app-section" id="metronome-section">
        <h2>BeatForge Metronome</h2>
        <h3>Click to accent strong beats</h3>
        <div class="controls">
            <select id="time-signature" aria-label="Select time signature">
                <option value="2">2/4</option>
                <option value="3">3/4</option>
                <option value="4" selected>4/4</option>
                <option value="6">6/8</option>
                <option value="7">7/8</option>
                <option value="8">8/8</option>
                <option value="12">12/8</option>
            </select>
            <select id="sound-type" aria-label="Select metronome sound">
                <option value="click">Click</option>
                <option value="woodblock">Woodblock</option>
                <option value="drums">Drums</option>
            </select>
            <div class="volume-control">
                <span>Metronome Volume:</span>
                <input type="range" id="metronome-volume" min="0" max="1" step="0.1" value="0.25" aria-label="Metronome volume">
            </div>
            <input type="range" id="tempo" min="40" max="220" value="120" aria-label="Tempo">
            <span id="tempo-display">120 BPM</span>
            <button id="tap-tempo" aria-label="Tap tempo">Tap Tempo</button>
            <button id="start-stop" aria-label="Start or stop metronome">Start</button>
        </div>
        <div class="beats-container"></div>
    </div>

    <div class="app-section" id="chord-progression-section">
        <h2>Chord Progression Practice</h2>
        <h3>Create a progression or pick one from the dropdown. Choose which key and scale to go with it.</h3>
        <label for="progression-select">Select Progression:</label>
        <select id="progression-select" aria-label="Select chord progression">
            <option value="I V7">I-V7</option>
            <option value="jazz_blues">Jazz Blues</option>
            <option value="minor_blues">Minor Blues</option>
            <option value="rhythm_changes">Rhythm Changes</option>
            <option value="2_5_1">II-V-I</option>
            <option value="6_2_5_1">VI-II-V-I</option>
            <option value="minor 2_5_1">Minor iim-V7-im</option>
            <option value="dark_eyes">Dark Eyes</option>
            <option value="black_orpheus">Black Orpheus</option>
            <option value="all_the_things_you_are">All The Things You Are</option>
            <option value="all_of_me">All of Me</option>
            <option value="stella_by_starlight">Stella By Starlight</option>
            <option value="autumn_leaves">Autumn Leaves</option>
            <option value="summertime">Summertime</option>
            <option value="girl_from_ipanema">Girl From Ipanema</option>
            <option value="coltrane_changes">Coltrane Changes</option>
            <option value="bird_blues">Bird Blues</option>
        </select>
        <label for="keySelect">Select Key:</label>
        <select id="keySelect" aria-label="Select key">
            <option value="C">C</option>
            <option value="Db">Db</option>
            <option value="D">D</option>
            <option value="Eb">Eb</option>
            <option value="E">E</option>
            <option value="F">F</option>
            <option value="Gb">Gb</option>
            <option value="G">G</option>
            <option value="Ab">Ab</option>
            <option value="A">A</option>
            <option value="Bb">Bb</option>
            <option value="B">B</option>
        </select>
        <div id="measures">
            <!-- Measures will be populated dynamically -->
        </div>
        <button onclick="addMeasure()" aria-label="Add measure">Add Measure</button>
        <button onclick="removeMeasure()" aria-label="Remove measure">Remove Measure</button>
        <div class="checkbox-wrapper">
            <input type="checkbox" id="chordsEnabled" checked aria-label="Enable chords">
            <label for="chordsEnabled">Enable Chords</label>
        </div>
        <div class="volume-control">
            <label for="chord-volume">Chord Volume:</label>
            <input type="range" id="chord-volume" min="0" max="1" step="0.1" value="0.75" aria-label="Chord volume">
        </div>
    </div>

    <div class="app-section" id="fretflow-section">
        <h2>FretFlow</h2>
        <h3>Multiple scale workout</h3>
        <div class="volume-control">
            <span>Fretboard Volume:</span>
            <input type="range" id="fretboard-volume" min="0" max="1" step="0.1" value="0.3" aria-label="Fretboard volume">
        </div>
        <div class="fretboards-grid"></div>
    </div>

    <script>
       <script>
// Utility Functions
function log(message) {
    console.log(`[FretFlow Debug] ${message}`);
}

function updateLoadingStatus(message) {
    let indicator = document.getElementById('loading-indicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'loading-indicator';
        document.body.appendChild(indicator);
    }
    indicator.textContent = message;
}

function debounce(func, wait) {
    let timeout;
    return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

// Musical Constants
const NOTES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

const ENHARMONIC_MAP = {
    'C#': 'Db', 'Db': 'Db',
    'D#': 'Eb', 'Eb': 'Eb',
    'F#': 'Gb', 'Gb': 'Gb',
    'G#': 'Ab', 'Ab': 'Ab',
    'A#': 'Bb', 'Bb': 'Bb'
};

const SAMPLE_NOTE_MAP = {
    'Gb': 'Fs', 'Eb': 'Ds', 'F#': 'Fs', 'D#': 'Ds'
};

const SAMPLED_NOTES = ['A', 'C', 'Ds', 'Fs'];
const PIANO_CONFIG = {
    octaves: {
        'A': [2, 3, 4, 5, 6],
        'C': [2, 3, 4, 5, 6],
        'Fs': [2, 3, 4, 5, 6],
        'Ds': [2, 3, 4, 5, 6]
    },
    velocities: [12],
    fileFormat: 'ogg'
};

const PIANO_NOTES = {
    'A2': 110.00, 'As2': 116.54, 'B2': 123.47,
    'C3': 130.81, 'Cs3': 138.59, 'D3': 146.83, 'Ds3': 155.56, 'E3': 164.81, 'F3': 174.61,
    'Fs3': 185.00, 'G3': 196.00, 'Gs3': 207.65, 'A3': 220.00, 'As3': 233.08, 'B3': 246.94,
    'C4': 261.63, 'Cs4': 277.18, 'D4': 293.66, 'Ds4': 311.13, 'E4': 329.63
};

const FRETBOARD_FREQUENCIES = {
    'string6': [82.41, 87.31, 92.50, 98.00, 103.83, 110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81],
    'string5': [110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81, 174.61, 185.00, 196.00, 207.65, 220.00],
    'string4': [146.83, 155.56, 164.81, 174.61, 185.00, 196.00, 207.65, 220.00, 233.08, 246.94, 261.63, 277.18, 293.66],
    'string3': [196.00, 207.65, 220.00, 233.08, 246.94, 261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00],
    'string2': [246.94, 261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88],
    'string1': [329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88, 523.25, 554.37, 587.33, 622.25, 659.25]
};

const SCALES = {
    major: [0, 2, 4, 5, 7, 9, 11],
    minor: [0, 2, 3, 5, 7, 8, 10],
    harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
    melodicMinor: [0, 2, 3, 5, 7, 9, 11],
    pentatonicMajor: [0, 2, 4, 7, 9],
    pentatonicMinor: [0, 3, 5, 7, 10],
    blues: [0, 3, 5, 6, 7, 10],
    dorian: [0, 2, 3, 5, 7, 9, 10],
    phrygian: [0, 1, 3, 5, 7, 8, 10],
    lydian: [0, 2, 4, 6, 7, 9, 11],
    mixolydian: [0, 2, 4, 5, 7, 9, 10],
    locrian: [0, 1, 3, 5, 6, 8, 10],
    diminished: [0, 2, 3, 5, 6, 8, 9, 11],
    diminishedWH: [0, 2, 3, 5, 6, 8, 9, 11],
    diminishedHW: [0, 1, 3, 4, 6, 7, 9, 10],
    bebopDominant: [0, 2, 4, 5, 7, 9, 10, 11],
    bebopMajor: [0, 2, 4, 5, 7, 8, 9, 11],
    bebopPhrygian: [0, 1, 3, 5, 7, 8, 9, 10]
};

const TUNINGS = {
    standard: ['E', 'B', 'G', 'D', 'A', 'E'],
    dropD: ['E', 'B', 'G', 'D', 'A', 'D'],
    openG: ['D', 'B', 'G', 'D', 'G', 'D'],
    DADGAD: ['D', 'A', 'G', 'D', 'A', 'D'],
    openE: ['E', 'B', 'E', 'Ab', 'B', 'E']
};

const DRUM_PATTERNS = {
    '2': { kick: [1, 0], snare: [0, 1], hihat: [1, 1] },
    '3': { kick: [1, 0, 0], snare: [0, 1, 0], hihat: [1, 1, 1] },
    '4': { kick: [1, 0, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1, 1] },
    '6': { kick: [1, 0, 0, 1, 0, 0], snare: [0, 0, 1, 0, 0, 1], hihat: [1, 1, 1, 1, 1, 1] },
    '7': { kick: [1, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1] },
    '8': { kick: [1, 0, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1, 1] },
    '12': { kick: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], snare: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], hihat: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }
};

const progressions = {
    "I V7": { defaultKey: "C", progression: ["I", "V7"] },
    "jazz_blues": { defaultKey: "Bb", progression: ["I7", "IV7", "I7", "I7", "IV7", "IV7", "I7", "VI7", "II7", "V7", "I7", "V7"] },
    "minor_blues": { defaultKey: "Am", progression: ["Im7", "IVm7", "Im7", "Im7", "bVI7", "V7", "Im7", "IVm7", "Im7", "bVII7", "Im7", "V7"] },
    "rhythm_changes": { defaultKey: "Bb", progression: ["I", "vi", "ii", "V", "I", "vi", "ii", "V", "I", "IV", "I", "I", "ii", "V", "I", "V7"] },
    "2_5_1": { defaultKey: "C", progression: ["ii", "V", "I", "I"] },
    "6_2_5_1": { defaultKey: "C", progression: ["vi", "ii", "V", "I", "I"] },
    "minor 2_5_1": { defaultKey: "Am", progression: ["iim7b5", "V7b9", "im7", "im7"] },
    "dark_eyes": { defaultKey: "Am", progression: ["i", "iv", "V7", "i", "iv", "V7", "i", "V7/iv", "iv", "V7/III", "III", "i", "iv", "V7", "i", "V7"] },
    "black_orpheus": { defaultKey: "Am", progression: ["im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7"] },
    "all_the_things_you_are": { defaultKey: "Ab", progression: ["vim7", "iim7", "V7", "Imaj7", "IVmaj7", "iiim7", "VI7", "IImaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7", "iim7", "V7", "bIIImaj7", "iim7", "V7", "bIIImaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7"] },
    "all_of_me": { defaultKey: "C", progression: ["Imaj7", "III7", "VI7", "iim7", "III7", "vim7", "II7", "iim7", "V7", "Imaj7", "III7", "VI7", "iim7", "IV", "bv", "Imaj7", "V7"] },
    "stella_by_starlight": { defaultKey: "Bb", progression: ["iim7b5", "V7b9", "im7", "IV7", "vm7", "I7", "IVmaj7", "bVIImaj7", "iiim7b5", "VI7b9", "im7", "IV7", "vm7", "I7", "IVmaj7", "VI7b9"] },
    "autumn_leaves": { defaultKey: "Bb", progression: ["iim7b5", "V7b9", "im7", "ivm7", "bVII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "ivm7", "bVII7", "bIIImaj7", "bVImaj7", "V7b9"] },
    "summertime": { defaultKey: "Am", progression: ["i", "V7", "i", "V7", "i", "V7", "i", "V7", "iv", "i", "V7", "i", "iv", "i", "V7", "i"] },
    "girl_from_ipanema": { defaultKey: "F", progression: ["Imaj7", "II7", "iim7", "V7", "Imaj7", "II7", "iim7", "V7", "Imaj7", "bII7", "Vmaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7"] },
    "coltrane_changes": { defaultKey: "C", progression: ["Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7", "Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7"] },
    "bird_blues": { defaultKey: "F", progression: ["I7", "IV7", "I7", "vim7", "I7", "IV7", "IV7", "bvo7", "I7", "vim7", "II7", "iim7", "V7"] }
};

const scaleDegrees = {
    major: {
        'I': 0, 'II': 2, 'III': 4, 'IV': 5, 'V': 7, 'VI': 9, 'VII': 11,
        'i': 0, 'ii': 2, 'iii': 4, 'iv': 5, 'v': 7, 'vi': 9, 'vii': 11,
        'I7': 0, 'II7': 2, 'III7': 4, 'IV7': 5, 'V7': 7, 'VI7': 9, 'VII7': 11,
        'Im7': 0, 'IIm7': 2, 'IIIm7': 4, 'IVm7': 5, 'Vm7': 7, 'VIm7': 9, 'VIIm7': 11,
        'Imaj7': 0, 'IImaj7': 2, 'IIImaj7': 4, 'IVmaj7': 5, 'Vmaj7': 7, 'VImaj7': 9,
        'bIII': 3, 'bVI': 8, 'bVII': 10,
        'bIIImaj7': 3, 'bVImaj7': 8, 'bVII7': 10
    },
    minor: {
        'i': 0, 'ii': 2, 'III': 3, 'iv': 5, 'v': 7, 'VI': 8, 'VII': 10,
        'im': 0, 'iim': 2, 'iiim': 3, 'ivm': 5, 'vm': 7, 'VIm': 8,
        'i7': 0, 'ii7': 2, 'III7': 3, 'iv7': 5, 'v7': 7, 'VI7': 8, 'VII7': 10,
        'im7': 0, 'iim7': 2, 'IIIm7': 3, 'ivm7': 5, 'vm7': 7, 'VIm7': 8,
        'iim7b5': 2, 'V7b9': 7,
        'bIII': 3, 'bVI': 8, 'bVII': 10,
        'bIIImaj7': 3, 'bVImaj7': 8
    }
};

// State Management
const AppState = {
    isPlaying: false,
    currentBeat: 0,
    currentMeasure: 0,
    tempo: 120,
    audioInitialized: false,
    darkMode: false,
    listeners: [],
    updateState(newState) {
        Object.assign(this, newState);
        this.notifyListeners();
    },
    addListener(callback) {
        this.listeners.push(callback);
    },
    notifyListeners() {
        this.listeners.forEach(callback => callback(this));
    }
};

// UI Management
const UI = {
    elements: {
        chordFretboard: document.getElementById('chord-fretboard'),
        measures: document.getElementById('measures'),
        tempoDisplay: document.getElementById('tempo-display'),
        startStopButton: document.getElementById('start-stop'),
        progressionSelect: document.getElementById('progression-select'),
        keySelect: document.getElementById('keySelect'),
        scaleDisplay: document.getElementById('scale-display'),
        chordTuning: document.getElementById('chord-tuning'),
        timeSignature: document.getElementById('time-signature'),
        soundType: document.getElementById('sound-type'),
        metronomeVolume: document.getElementById('metronome-volume'),
        tempo: document.getElementById('tempo'),
        tapTempo: document.getElementById('tap-tempo'),
        chordFretboardVolume: document.getElementById('chord-fretboard-volume'),
        chordVolume: document.getElementById('chord-volume'),
        chordsEnabled: document.getElementById('chordsEnabled'),
        fretboardVolume: document.getElementById('fretboard-volume'),
        fretboardsGrid: document.querySelector('.fretboards-grid'),
        darkModeToggle: document.getElementById('dark-mode-toggle')
    },
    init() {
        Object.entries(this.elements).forEach(([key, el]) => {
            if (!el) console.warn(`Missing DOM element: ${key}`);
        });
    }
};

// Audio Management
const AudioContextManager = {
    context: null,
    soundBuffers: {},
    pianoSampleBuffers: {},
    reverbNode: null,
    samplesLoaded: false,
    currentChordGain: null,
    async initialize() {
        if (!this.context) {
            this.context = new (window.AudioContext || window.webkitAudioContext)();
            await this.loadSounds();
            await this.loadPianoSamples();
            await this.setupReverb();
        }
        if (this.context.state === 'suspended') {
            await this.context.resume();
        }
        AppState.updateState({ audioInitialized: true });
        return this.context;
    },
    async ensureAudioContext() {
        return await this.initialize();
    },
    async loadSounds() {
        const soundFiles = {
            'click': 'Click.wav',
            'hihat': 'HiHat.wav',
            'kick': 'Kick.wav',
            'snare': 'Snare.wav',
            'woodblock': 'woodblock.wav'
        };
        for (let [type, filename] of Object.entries(soundFiles)) {
            try {
                const response = await fetch(`./${filename}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const arrayBuffer = await response.arrayBuffer();
                this.soundBuffers[type] = await this.context.decodeAudioData(arrayBuffer);
                log(`Loaded ${type} sound from ${filename}`);
            } catch (error) {
                console.error(`Failed to load ${filename}:`, error);
                this.soundBuffers[type] = await this.createDrumSound(type);
                log(`Using fallback synthetic sound for ${type}`);
            }
        }
        updateLoadingStatus("Drum sounds loaded");
    },
    async createDrumSound(type) {
        const sampleRate = this.context.sampleRate;
        const duration = type === 'hihat' ? 0.05 : 0.2;
        const buffer = this.context.createBuffer(1, sampleRate * duration, sampleRate);
        const data = buffer.getChannelData(0);
        switch (type) {
            case 'click':
                for (let i = 0; i < data.length; i++) data[i] = Math.sin(i * 0.05) * Math.exp(-i * 0.01);
                break;
            case 'hihat':
                for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.01));
                break;
            case 'kick':
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    data[i] = Math.sin(2 * Math.PI * 100 * t) * Math.exp(-t * 10) * 2;
                }
                break;
            case 'snare':
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    data[i] = ((Math.random() * 2 - 1) + Math.sin(2 * Math.PI * 200 * t)) * Math.exp(-t * 10) * 2;
                }
                break;
            case 'woodblock':
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    data[i] = Math.sin(2 * Math.PI * 800 * t) * Math.exp(-t * 20);
                }
                break;
        }
        return buffer;
    },
    async loadPianoSamples() {
        log('Starting piano sample loading...');
        if (!this.context) {
            await this.initialize();
        }
        for (let note of SAMPLED_NOTES) {
            for (let octave of PIANO_CONFIG.octaves[note]) {
                const sampleName = `${note}${octave}v12`;
                try {
                    const response = await fetch(`./${sampleName}.${PIANO_CONFIG.fileFormat}`);
                    if (!response.ok) throw new Error(`Failed to load ${sampleName}`);
                    const arrayBuffer = await response.arrayBuffer();
                    this.pianoSampleBuffers[sampleName] = await this.context.decodeAudioData(arrayBuffer);
                    log(`Loaded piano sample: ${sampleName}`);
                } catch (error) {
                    console.warn(`Could not load ${sampleName}, using fallback`, error);
                    this.pianoSampleBuffers[sampleName] = this.createSyntheticSample(note, octave);
                }
            }
        }
        this.samplesLoaded = true;
        updateLoadingStatus("Piano samples loaded");
    },
    createSyntheticSample(note, octave) {
        const buffer = this.context.createBuffer(1, this.context.sampleRate, this.context.sampleRate);
        const data = buffer.getChannelData(0);
        const frequency = PIANO_NOTES[`${note}${octave}`] || 440;
        for (let i = 0; i < data.length; i++) {
            data[i] = Math.sin(2 * Math.PI * frequency * i / this.context.sampleRate) * Math.exp(-i / this.context.sampleRate);
        }
        return buffer;
    },
    async setupReverb() {
        if (!this.reverbNode) {
            this.reverbNode = this.context.createConvolver();
            const sampleRate = this.context.sampleRate;
            const length = sampleRate * 2.5;
            const impulse = this.context.createBuffer(2, length, sampleRate);
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                }
            }
            this.reverbNode.buffer = impulse;
            this.reverbNode.connect(this.context.destination);
        }
    }
};

// Music Theory Utilities
function standardizeNoteName(note) {
    if (!note) return 'C';
    const isMinor = note.trim().endsWith('m') || note.trim().endsWith('min');
    const baseNote = note.trim().replace(/m$|min$/, '');
    const standardized = ENHARMONIC_MAP[baseNote] || baseNote;
    return isMinor ? standardized + 'm' : standardized;
}

function getNoteIndex(note) {
    const standardizedNote = standardizeNoteName(note);
    return NOTES.indexOf(standardizedNote);
}

function findNearestSampledNote(note, octave) {
    let minDistance = Infinity;
    let nearestNote = null;
    let nearestOctave = octave;
    const sampleNote = SAMPLE_NOTE_MAP[note] || note;
    const noteIndex = NOTES.indexOf(note);
    for (let sampledNote of SAMPLED_NOTES) {
        const compareNote = sampledNote === 'Fs' ? 'Gb' : sampledNote === 'Ds' ? 'Eb' : sampledNote;
        const sampledIndex = NOTES.indexOf(standardizeNoteName(compareNote));
        const distance = Math.abs(noteIndex - sampledIndex);
        if (distance < minDistance) {
            minDistance = distance;
            nearestNote = sampledNote;
            if (noteIndex < sampledIndex && noteIndex < 3 && sampledIndex > 8) {
                nearestOctave = octave - 1;
            } else if (noteIndex > sampledIndex && noteIndex > 8 && sampledIndex < 3) {
                nearestOctave = octave + 1;
            }
        }
    }
    // Ensure octave stays within A2–C4 range
    nearestOctave = Math.max(2, Math.min(3, nearestOctave));
    return {
        sampleKey: `${nearestNote}${nearestOctave}v12`,
        semitoneDiff: (noteIndex - NOTES.indexOf(standardizeNoteName(nearestNote === 'Fs' ? 'Gb' : nearestNote === 'Ds' ? 'Eb' : nearestNote)) + 12) % 12
    };
}

function getPitchShiftedNote(note, octave) {
    const standardNote = standardizeNoteName(note);
    const nearest = findNearestSampledNote(standardNote, octave);
    const playbackRate = Math.pow(2, nearest.semitoneDiff / 12);
    return {
        sampleKey: nearest.sampleKey,
        playbackRate: playbackRate
    };
}

function isMinorKeyName(key) {
    return key && (key.endsWith('m') || key.endsWith('min'));
}

function getChordFromFunction(key, func) {
    if (!key || !func) return null;
    const isMinor = isMinorKeyName(key);
    const rootKey = key.replace(/m$|min$/, '');
    const standardizedKey = standardizeNoteName(rootKey);
    const keyIndex = NOTES.indexOf(standardizedKey);
    if (keyIndex === -1) {
        console.error(`Invalid key: ${key}`);
        return null;
    }
    const degrees = isMinor ? scaleDegrees.minor : scaleDegrees.major;
    let degree = degrees[func];
    if (degree === undefined) {
        // Handle secondary dominants (e.g., V7/iv)
        if (func.includes('/')) {
            const [secondary, target] = func.split('/');
            const targetDegree = degrees[target.toLowerCase()];
            if (targetDegree !== undefined && secondary.startsWith('V7')) {
                degree = (targetDegree + 7) % 12; // V7 of the target chord
            } else {
                console.error(`Invalid secondary function: ${func}`);
                return null;
            }
        } else {
            console.error(`Invalid chord function: ${func}`);
            return null;
        }
    }
    const noteIndex = (keyIndex + degree) % 12;
    const note = NOTES[noteIndex];
    let quality = '';
    if (func.includes('m7b5') || func.includes('ø')) quality = 'min7b5';
    else if (func.includes('7b9')) quality = '7b9';
    else if (func.includes('maj7')) quality = 'maj7';
    else if (func.includes('m7') || func.includes('min7')) quality = 'm7';
    else if (func.includes('7')) quality = '7';
    else if (func.match(/^[iv]/) && !func.includes('maj') && !func.includes('7')) quality = 'm';
    else if (func.includes('°')) quality = 'dim';
    return note + quality;
}

function parseChord(chord) {
    if (!chord) return ['C', ''];
    // Updated regex to handle flats/sharps and more chord types
    const regex = /^([A-G][b#]?)(m7b5|7b9|maj7|m7|7|m|dim|aug|sus2|sus4|add9|6|9|11|13|°)?$/;
    const match = chord.match(regex);
    if (!match) {
        console.warn(`Unable to parse chord: ${chord}`);
        return [standardizeNoteName(chord), ''];
    }
    const [_, root, quality] = match;
    let standardQuality = quality || '';
    if (quality === 'min7') standardQuality = 'm7';
    return [standardizeNoteName(root), standardQuality];
}

function getQualityValue(quality) {
    const qualityMap = {
        '': 'major',
        'm': 'minor',
        '7': 'dom7',
        'maj7': 'maj7',
        'm7': 'min7',
        'dim': 'dim',
        'min7b5': 'min7b5'
    };
    return qualityMap[quality] || 'major';
}

function suggestScaleForQuality(quality) {
    const scaleMap = {
        'major': 'major',
        'minor': 'minor',
        'dom7': 'mixolydian',
        'maj7': 'major',
        'min7': 'dorian',
        'dim': 'diminished',
        'min7b5': 'locrian'
    };
    return scaleMap[quality] || 'major';
}

// DOM Utilities
function createKeyOptions(selected = 'C') {
    return NOTES.map(note =>
        `<option value="${note}"${note === selected ? ' selected' : ''}>${note}</option>`
    ).join('');
}

function createQualityOptions(selected = 'major') {
    const qualities = [
        { value: 'major', label: 'Major' },
        { value: 'minor', label: 'Minor' },
        { value: 'dom7', label: '7' },
        { value: 'maj7', label: 'Maj7' },
        { value: 'min7', label: 'Min7' },
        { value: 'min7b5', label: 'Min7b5 (Half Diminished)' }
    ];
    return qualities.map(q =>
        `<option value="${q.value}"${q.value === selected ? ' selected' : ''}>${q.label}</option>`
    ).join('');
}

function createScaleOptions(selected = 'major') {
    return Object.keys(SCALES).map(scale =>
        `<option value="${scale}"${scale === selected ? ' selected' : ''}>${scale.charAt(0).toUpperCase() + scale.slice(1)}</option>`
    ).join('');
}

// Audio Playback
async function playNote(string, fret, volume) {
    await AudioContextManager.ensureAudioContext();
    if (!FRETBOARD_FREQUENCIES[string] || volume <= 0) return;
    const frequency = FRETBOARD_FREQUENCIES[string][fret];
    let closestNote = null;
    let minDifference = Infinity;
    // Match fretboard frequency to piano note in A2–C4 range
    for (const [note, noteFreq] of Object.entries(PIANO_NOTES)) {
        const difference = Math.abs(frequency - noteFreq);
        if (difference < minDifference) {
            minDifference = difference;
            closestNote = note;
        }
    }
    if (!closestNote) return;
    const noteName = closestNote.match(/[A-G][b#]?/)[0];
    const octave = parseInt(closestNote.match(/\d/)[0]);
    const { sampleKey, playbackRate } = getPitchShiftedNote(noteName, octave);
    const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];
    if (buffer) {
        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;
        source.playbackRate.value = playbackRate;
        const gainNode = AudioContextManager.context.createGain();
        gainNode.gain.value = volume;
        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);
        source.start();
        source.stop(AudioContextManager.context.currentTime + 0.5);
    }
}

async function playChord(root, quality, startTime = AudioContextManager.context.currentTime, duration = 1, isPassingChord = false) {
    if (!UI.elements.chordsEnabled.checked) return;
    await AudioContextManager.ensureAudioContext();
    const chordVolume = parseFloat(UI.elements.chordVolume.value) || 0.75;
    if (chordVolume <= 0) return;
    const chordNotes = getChordNotes(root, quality);
    if (AudioContextManager.currentChordGain) {
        AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, startTime);
        AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);
    }
    AudioContextManager.currentChordGain = AudioContextManager.context.createGain();
    AudioContextManager.currentChordGain.gain.setValueAtTime(chordVolume, startTime);
    AudioContextManager.currentChordGain.connect(AudioContextManager.context.destination);
    chordNotes.forEach(note => {
        // Use octave 3 for chord roots, adjust others to stay within A2–C4
        const { sampleKey, playbackRate } = getPitchShiftedNote(note, 3);
        const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];
        if (buffer) {
            const source = AudioContextManager.context.createBufferSource();
            source.buffer = buffer;
            source.playbackRate.value = playbackRate;
            source.connect(AudioContextManager.currentChordGain);
            source.start(startTime);
            source.stop(startTime + duration);
        }
    });
}

function getChordNotes(root, quality) {
    const rootIndex = NOTES.indexOf(standardizeNoteName(root));
    const intervals = {
        major: [0, 4, 7],
        minor: [0, 3, 7],
        dom7: [0, 4, 7, 10],
        maj7: [0, 4, 7, 11],
        min7: [0, 3, 7, 10],
        min7b5: [0, 3, 6, 10]
    }[quality] || [0, 4, 7];
    return intervals.map(interval => NOTES[(rootIndex + interval) % 12]);
}

async function playMetronomeSound(volume) {
    if (!AudioContextManager.context || volume <= 0) return;
    const soundType = UI.elements.soundType.value;
    const beatElement = document.querySelector(`.beat[data-beat="${AppState.currentBeat}"]`);
    const drumSound = beatElement?.dataset.sound || 'default';
    let soundKey = soundType;
    if (soundType === 'drums' && drumSound !== 'default') {
        soundKey = drumSound;
    }
    const buffer = AudioContextManager.soundBuffers[soundKey] || AudioContextManager.soundBuffers['click'];
    if (!buffer) return;
    const source = AudioContextManager.context.createBufferSource();
    source.buffer = buffer;
    const gainNode = AudioContextManager.context.createGain();
    gainNode.gain.value = volume;
    source.connect(gainNode);
    gainNode.connect(AudioContextManager.context.destination);
    source.start();
}

// Fretboard Management
function createFretboard(container, tuning) {
    if (!(container instanceof HTMLElement)) return;
    container.innerHTML = '';
    const markersContainer = document.createElement('div');
    markersContainer.style.position = 'absolute';
    markersContainer.style.width = '100%';
    markersContainer.style.height = '100%';
    markersContainer.style.pointerEvents = 'none';
    container.appendChild(markersContainer);
    [3, 5, 7, 9, 12].forEach(fret => {
        const marker = document.createElement('div');
        marker.className = 'fret-marker';
        marker.style.left = `${((fret - 0.5) / 12) * 100}%`;
        if (fret === 12) {
            const marker1 = marker.cloneNode();
            marker1.style.top = '40%';
            markersContainer.appendChild(marker1);
            const marker2 = marker.cloneNode();
            marker2.style.top = '60%';
            markersContainer.appendChild(marker2);
        } else {
            marker.style.top = '50%';
            markersContainer.appendChild(marker);
        }
    });
    for (let i = 0; i <= 12; i++) {
        const fretLine = document.createElement('div');
        fretLine.className = 'fret-line';
        fretLine.style.left = `${(i / 12) * 100}%`;
        container.appendChild(fretLine);
        if ([3, 5, 7, 9, 12].includes(i)) {
            const fretNumber = document.createElement('div');
            fretNumber.className = 'fret-number';
            fretNumber.textContent = i;
            fretNumber.style.left = `${(i / 12) * 100}%`;
            container.appendChild(fretNumber);
        }
    }
    for (let i = 0; i < 6; i++) {
        const stringLine = document.createElement('div');
        stringLine.className = 'string-line';
        stringLine.style.top = `${(i / 5) * 100}%`;
        container.appendChild(stringLine);
    }
}

function updateFretboardNotes(container, rootNote, scale, tuning) {
    if (!(container instanceof HTMLElement)) {
        console.error('Invalid container element');
        return;
    }
    if (!NOTES.includes(standardizeNoteName(rootNote))) {
        console.error(`Invalid root note: ${rootNote}`);
        return;
    }
    if (!SCALES[scale]) {
        console.error(`Invalid scale: ${scale}`);
        return;
    }
    if (!Array.isArray(tuning) || tuning.length !== 6) {
        console.error('Invalid tuning');
        return;
    }
    container.querySelectorAll('.note').forEach(note => note.remove());
    if (container.id === 'chord-fretboard') {
        const measures = UI.elements.measures.children;
        if (measures.length > 0 && AppState.currentMeasure < measures.length) {
            const currentMeasureElement = measures[AppState.currentMeasure];
            const chordRoot = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
            const chordQuality = currentMeasureElement.querySelector('.chord-controls .chord-quality')?.value;
            const scaleRoot = currentMeasureElement.querySelector('.scale-controls .second-key')?.value;
            const scaleType = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;
            if (chordRoot && chordQuality && scaleRoot && scaleType) {
                let displayQuality = chordQuality;
                switch (chordQuality) {
                    case 'dom7': displayQuality = '7'; break;
                    case 'maj7': displayQuality = 'Maj7'; break;
                    case 'min7': displayQuality = 'm7'; break;
                    case 'min7b5': displayQuality = 'm7b5'; break;
                    case 'minor': displayQuality = 'm'; break;
                }
                let displayScale = scaleType.charAt(0).toUpperCase() + scaleType.slice(1);
                displayScale = displayScale.replace(/([A-Z])/g, ' $1').trim();
                UI.elements.scaleDisplay.textContent = `${scaleRoot} ${displayScale} over ${chordRoot} ${displayQuality}`;
            }
        }
    }
    const scaleIntervals = SCALES[scale];
    const standardizedRoot = standardizeNoteName(rootNote);
    const rootIndex = NOTES.indexOf(standardizedRoot);
    const scaleNotes = scaleIntervals.map(interval => {
        const noteIndex = (rootIndex + interval) % 12;
        return NOTES[noteIndex];
    });
    for (let string = 0; string < 6; string++) {
        const openNote = tuning[string];
        const openNoteIndex = NOTES.indexOf(openNote);
        for (let fret = 0; fret <= 12; fret++) {
            const noteIndex = (openNoteIndex + fret) % 12;
            const currentNote = NOTES[noteIndex];
            if (scaleNotes.includes(currentNote)) {
                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                noteElement.textContent = currentNote;
                const fretOffset = fret === 0 ? 0 : ((fret - 0.5) / 12) * 100;
                noteElement.style.left = `${fretOffset}%`;
                noteElement.style.top = `${(string / 5) * 100}%`;
                const degree = scaleNotes.indexOf(currentNote);
                if (currentNote === standardizedRoot) {
                    noteElement.style.backgroundColor = '#BD2031';
                } else if ([2, 4, 6].includes(degree)) {
                    noteElement.style.backgroundColor = '#006400';
                } else {
                    noteElement.style.backgroundColor = '#4CAF50';
                }
                noteElement.addEventListener('click', async () => {
                    try {
                        await AudioContextManager.ensureAudioContext();
                        const volume = parseFloat(UI.elements.chordFretboardVolume.value) || 0.3;
                        await playNote(`string${6 - string}`, fret, volume);
                        noteElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
                        setTimeout(() => {
                            noteElement.style.transform = 'translate(-50%, -50%) scale(1)';
                        }, 100);
                    } catch (error) {
                        console.error('Error playing note:', error);
                    }
                });
                noteElement.addEventListener('mouseenter', () => {
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1.1)';
                });
                noteElement.addEventListener('mouseleave', () => {
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1)';
                });
                container.appendChild(noteElement);
            }
        }
    }
    log(`Fretboard updated with ${rootNote} ${scale} scale`);
}

// Metronome Management
function createBeats() {
    const container = document.querySelector('.beats-container');
    container.innerHTML = '';
    const timeSignature = parseInt(UI.elements.timeSignature.value);
    const soundType = UI.elements.soundType.value;
    const totalBeats = timeSignature === 4 ? 8 : timeSignature;
    const beatConfigs = {
        4: { strongBeats: [0, 4], drumSounds: { 0: 'kick', 2: 'snare', 4: 'kick', 6: 'snare' } },
        6: { strongBeats: [0, 3] },
        7: { strongBeats: [0, 4] },
        12: { strongBeats: [0, 3, 6, 9] }
    };
    const config = beatConfigs[timeSignature] || { strongBeats: [0] };
    for (let i = 0; i < totalBeats; i++) {
        const beat = document.createElement('div');
        beat.className = 'beat';
        beat.dataset.beat = i;
        let volume = '0.3';
        let color = '#4CAF50';
        let sound = 'default';
        if (timeSignature === 4) {
            const isEighth = i % 2 === 1;
            beat.textContent = `${Math.floor(i / 2 + 1)}${isEighth ? '&' : ''}`;
            if (soundType === 'drums') {
                if (isEighth) {
                    volume = '1';
                    sound = 'hihat';
                    color = '#9E9E9E';
                } else {
                    sound = config.drumSounds[i] || 'hihat';
                    volume = '1';
                    color = sound === 'kick' ? '#1F618D' : sound === 'snare' ? '#4CAF50' : '#9E9E9E';
                }
            } else {
                volume = isEighth ? '0' : i === 0 ? '1' : '0.3';
                color = isEighth ? '#9E9E9E' : i === 0 ? '#1F618D' : '#4CAF50';
            }
        } else {
            beat.textContent = i + 1;
            volume = config.strongBeats.includes(i) ? '1' : '0.3';
            color = config.strongBeats.includes(i) ? '#1F618D' : '#4CAF50';
        }
        beat.dataset.volume = volume;
        beat.dataset.sound = sound;
        beat.style.backgroundColor = color;
        beat.addEventListener('click', () => toggleBeatState(beat, timeSignature, soundType));
        container.appendChild(beat);
    }
}

function toggleBeatState(beat, timeSignature, soundType) {
    const isEighth = timeSignature === 4 && parseInt(beat.dataset.beat) % 2 === 1;
    const states = soundType === 'drums' && timeSignature === 4 ? (
        isEighth ? [
            { volume: '1', sound: 'hihat', color: '#9E9E9E' },
            { volume: '1', sound: 'kick', color: '#1F618D' },
            { volume: '1', sound: 'snare', color: '#4CAF50' },
            { volume: '0', sound: 'silent', color: '#6666' }
        ] : [
            { volume: '1', sound: 'kick', color: '#1F618D' },
            { volume: '1', sound: 'snare', color: '#4CAF50' },
            { volume: '1', sound: 'hihat', color: '#9E9E9E' },
            { volume: '0', sound: 'silent', color: '#6666' }
        ]
    ) : [
        { volume: '1', sound: 'default', color: '#1F618D' },
        { volume: '0.3', sound: 'default', color: '#4CAF50' },
        { volume: '0', sound: 'default', color: '#9E9E9E' }
    ];
    const currentIndex = states.findIndex(state =>
        state.volume === beat.dataset.volume && state.sound === beat.dataset.sound
    );
    const nextState = states[(currentIndex + 1) % states.length];
    beat.dataset.volume = nextState.volume;
    beat.dataset.sound = nextState.sound;
    beat.style.backgroundColor = nextState.color;
}

async function playBeat() {
    const beats = document.querySelectorAll('.beat');
    beats.forEach(beat => beat.classList.remove('active'));
    const currentBeatElement = beats[AppState.currentBeat];
    if (currentBeatElement) {
        currentBeatElement.classList.add('active');
        const volume = parseFloat(currentBeatElement.dataset.volume) || 0;
        await playMetronomeSound(volume);
    }
    const measures = UI.elements.measures.children;
    const timeSignature = parseInt(UI.elements.timeSignature.value);
    if (measures.length > 0) {
        const currentMeasureElement = measures[AppState.currentMeasure];
        if (currentMeasureElement) {
            const root = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
            const quality = currentMeasureElement.querySelector('.chord-controls .chord-quality')?.value;
            const scaleRoot = currentMeasureElement.querySelector('.scale-controls .second-key')?.value;
            const scaleType = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;
            if (root && quality && scaleRoot && scaleType) {
                const chordTuning = TUNINGS[UI.elements.chordTuning.value];
                updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, chordTuning);
                const beatDuration = 60 / AppState.tempo;
                if (timeSignature === 4) {
                    if (AppState.currentBeat === 0) {
                        playChord(root, quality, AudioContextManager.context.currentTime, beatDuration * 2, false);
                    } else if (AppState.currentBeat === 4) {
                        playChord(root, quality, AudioContextManager.context.currentTime, beatDuration * 2, true);
                    }
                } else if (AppState.currentBeat === 0) {
                    playChord(root, quality, AudioContextManager.context.currentTime, beatDuration * 4, false);
                }
            }
        }
    }
    if (measures.length > 0) {
        Array.from(measures).forEach((measure, index) => {
            measure.classList.toggle('active', index === AppState.currentMeasure);
        });
    }
    const totalBeats = timeSignature === 4 ? 8 : timeSignature;
    AppState.currentBeat = (AppState.currentBeat + 1) % totalBeats;
    if (AppState.currentBeat === 0 && measures.length > 0) {
        AppState.currentMeasure = (AppState.currentMeasure + 1) % measures.length;
    }
    AppState.updateState({ currentBeat: AppState.currentBeat, currentMeasure: AppState.currentMeasure });
}

function startPlayback() {
    if (AppState.isPlaying) return;
    const timeSignature = parseInt(UI.elements.timeSignature.value);
    const measures = UI.elements.measures.children;
    if (measures.length === 0) {
        console.warn('No measures defined. Please add at least one measure.');
        return;
    }
    let interval = (60 / AppState.tempo) * 1000;
    if (timeSignature === 4) {
        interval = interval / 2;
    }
    AppState.updateState({ currentBeat: 0, currentMeasure: 0 });
    clearInterval(AppState.intervalId);
    const currentMeasureElement = measures[AppState.currentMeasure];
    if (currentMeasureElement) {
        const root = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
        const quality = currentMeasureElement.querySelector('.chord-controls .chord-quality')?.value;
        const scaleRoot = currentMeasureElement.querySelector('.scale-controls .second-key')?.value;
        const scaleType = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;
        if (root && quality && scaleRoot && scaleType) {
            const chordTuning = TUNINGS[UI.elements.chordTuning.value];
            updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, chordTuning);
            playChord(root, quality);
        }
    }
    AppState.intervalId = setInterval(playBeat, interval);
    AppState.updateState({ isPlaying: true });
    UI.elements.startStopButton.textContent = 'Stop';
    log("Playback started");
}

function stopPlayback() {
    clearInterval(AppState.intervalId);
    AppState.intervalId = null;
    AppState.updateState({ isPlaying: false, currentBeat: 0, currentMeasure: 0 });
    const beats = document.querySelectorAll('.beat');
    beats.forEach(beat => beat.classList.remove('active'));
    const measures = UI.elements.measures.children;
    Array.from(measures).forEach(measure => measure.classList.remove('active'));
    if (AudioContextManager.currentChordGain) {
        AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, AudioContextManager.context.currentTime);
        AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, AudioContextManager.context.currentTime + 0.1);
        AudioContextManager.currentChordGain = null;
    }
    UI.elements.startStopButton.textContent = 'Start';
    log("Playback stopped");
}

// Chord Progression Management
function loadProgression(progressionName, key) {
    if (!progressionName || !progressions[progressionName]) {
        console.error(`Invalid progression name: ${progressionName}`);
        return;
    }
    const progression = progressions[progressionName];
    // Use defaultKey directly to ensure correct key loading
    const selectedKey = key || progression.defaultKey;
    UI.elements.keySelect.value = selectedKey;
    UI.elements.measures.innerHTML = '';
    progression.progression.forEach((chordFunction, index) => {
        const chord = getChordFromFunction(selectedKey, chordFunction);
        const [root, quality] = parseChord(chord);
        const measure = document.createElement('div');
        measure.className = 'measure';
        measure.draggable = true;
        measure.innerHTML = `
            <span class="measure-number">${index + 1}</span>
            <div class="chord-controls">
                <select class="root-note">${createKeyOptions(root)}</select>
                <select class="chord-quality">${createQualityOptions(getQualityValue(quality))}</select>
            </div>
            <div class="scale-controls">
                <select class="second-key">${createKeyOptions(root)}</select>
                <select class="scale-select">${createScaleOptions(suggestScaleForQuality(quality))}</select>
            </div>
        `;
        UI.elements.measures.appendChild(measure);
        measure.addEventListener('dragstart', dragStart);
        measure.addEventListener('dragover', dragOver);
        measure.addEventListener('drop', drop);
        measure.addEventListener('dragend', dragEnd);
    });
    updateMeasureNumbers();
    addFirstChordListener();
    const firstMeasure = UI.elements.measures.firstElementChild;
    if (firstMeasure) {
        const scaleRoot = firstMeasure.querySelector('.second-key').value;
        const scaleType = firstMeasure.querySelector('.scale-select').value;
        const tuning = TUNINGS[UI.elements.chordTuning.value];
        updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning);
    }
    log(`Progression loaded: ${progressionName} in key ${selectedKey}`);
}

function updateProgressionKey(newKey) {
    const selectedProgression = UI.elements.progressionSelect.value;
    if (!selectedProgression) return;
    const progression = progressions[selectedProgression];
    if (!progression) return;
    Array.from(UI.elements.measures.children).forEach((measure, index) => {
        const chordFunc = progression.progression[index];
        if (!chordFunc) return;
        const chord = getChordFromFunction(newKey, chordFunc);
        const [root, quality] = parseChord(chord);
        const rootSelect = measure.querySelector('.root-note');
        const qualitySelect = measure.querySelector('.chord-quality');
        const secondKeySelect = measure.querySelector('.second-key');
        const scaleSelect = measure.querySelector('.scale-select');
        if (rootSelect) rootSelect.value = standardizeNoteName(root);
        if (qualitySelect) qualitySelect.value = getQualityValue(quality);
        if (secondKeySelect) secondKeySelect.value = standardizeNoteName(root);
        if (scaleSelect) scaleSelect.value = suggestScaleForQuality(getQualityValue(quality));
    });
    const firstMeasure = UI.elements.measures.firstElementChild;
    if (firstMeasure) {
        const scaleRoot = firstMeasure.querySelector('.second-key').value;
        const scaleType = firstMeasure.querySelector('.scale-select').value;
        const tuning = TUNINGS[UI.elements.chordTuning.value];
        updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning);
    }
    log(`Progression updated to key: ${newKey}`);
}

function addMeasure(chord = 'C', quality = 'major', scaleRoot = 'C', scaleType = 'major') {
    const measure = document.createElement('div');
    measure.className = 'measure';
    measure.draggable = true;
    const measureCount = UI.elements.measures.children.length + 1;
    measure.innerHTML = `
        <span class="measure-number">${measureCount}</span>
        <div class="chord-controls">
            <select class="root-note">${createKeyOptions(chord)}</select>
            <select class="chord-quality">${createQualityOptions(quality)}</select>
        </div>
        <div class="scale-controls">
            <select class="second-key">${createKeyOptions(scaleRoot)}</select>
            <select class="scale-select">${createScaleOptions(scaleType)}</select>
        </div>
    `;
    UI.elements.measures.appendChild(measure);
    measure.addEventListener('dragstart', dragStart);
    measure.addEventListener('dragover', dragOver);
    measure.addEventListener('drop', drop);
    measure.addEventListener('dragend', dragEnd);
    updateMeasureNumbers();
    log(`Added measure ${measureCount}`);
}

function removeMeasure() {
    const measures = UI.elements.measures.children;
    if (measures.length > 0) {
        measures[measures.length - 1].remove();
        updateMeasureNumbers();
        log(`Removed last measure`);
    }
}

function updateMeasureNumbers() {
    Array.from(UI.elements.measures.children).forEach((measure, index) => {
        const number = measure.querySelector('.measure-number');
        if (number) number.textContent = index + 1;
    });
}

// Drag and Drop Handlers
function dragStart(e) {
    e.dataTransfer.setData('text/plain', Array.from(UI.elements.measures.children).indexOf(e.target));
    setTimeout(() => e.target.classList.add('dragging'), 0);
}

function dragOver(e) {
    e.preventDefault();
}

function drop(e) {
    e.preventDefault();
    const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
    const targetIndex = Array.from(UI.elements.measures.children).indexOf(e.target.closest('.measure'));
    if (draggedIndex === targetIndex || isNaN(draggedIndex) || isNaN(targetIndex)) return;
    const measures = Array.from(UI.elements.measures.children);
    const draggedMeasure = measures[draggedIndex];
    UI.elements.measures.insertBefore(draggedMeasure, targetIndex < draggedIndex ? measures[targetIndex] : measures[targetIndex + 1]);
    updateMeasureNumbers();
    log(`Moved measure from index ${draggedIndex} to ${targetIndex}`);
}

function dragEnd(e) {
    e.target.classList.remove('dragging');
}

// FretFlow Section
function initializeFretFlow() {
    const fretboardsGrid = UI.elements.fretboardsGrid;
    const scales = ['major', 'minor', 'dorian', 'mixolydian'];
    const tuning = TUNINGS[UI.elements.chordTuning.value];
    fretboardsGrid.innerHTML = '';
    scales.forEach((scale, index) => {
        const container = document.createElement('div');
        container.className = 'fretboard-container';
        container.innerHTML = `
            <div class="scale-display">${UI.elements.keySelect.value} ${scale.charAt(0).toUpperCase() + scale.slice(1)}</div>
            <div class="controls">
                <select class="tuning-select" id="fretflow-tuning-${index}" aria-label="Select guitar tuning">
                    <option value="standard">Standard (EADGBE)</option>
                    <option value="dropD">Drop D (DADGBE)</option>
                    <option value="openG">Open G (DGDGBD)</option>
                    <option value="DADGAD">DADGAD</option>
                    <option value="openE">Open E (EBEG#BE)</option>
                </select>
            </div>
            <div id="fretflow-fretboard-${index}" class="fretboard"></div>
        `;
        fretboardsGrid.appendChild(container);
        const fretboard = container.querySelector(`#fretflow-fretboard-${index}`);
        createFretboard(fretboard, tuning);
        updateFretboardNotes(fretboard, UI.elements.keySelect.value, scale, tuning);
        const tuningSelect = container.querySelector(`#fretflow-tuning-${index}`);
        tuningSelect.addEventListener('change', () => {
            const newTuning = TUNINGS[tuningSelect.value];
            createFretboard(fretboard, newTuning);
            updateFretboardNotes(fretboard, UI.elements.keySelect.value, scale, newTuning);
        });
    });
    log("FretFlow initialized");
}

// Event Listeners
function addFirstChordListener() {
    const firstMeasure = UI.elements.measures.firstElementChild;
    if (firstMeasure) {
        const scaleRoot = firstMeasure.querySelector('.second-key');
        const scaleType = firstMeasure.querySelector('.scale-select');
        const updateFretboard = () => {
            const tuning = TUNINGS[UI.elements.chordTuning.value];
            updateFretboardNotes(UI.elements.chordFretboard, scaleRoot.value, scaleType.value, tuning);
        };
        scaleRoot.addEventListener('change', updateFretboard);
        scaleType.addEventListener('change', updateFretboard);
    }
}

function setupEventListeners() {
    UI.elements.startStopButton.addEventListener('click', () => {
        if (AppState.isPlaying) {
            stopPlayback();
        } else {
            startPlayback();
        }
    });

    UI.elements.tempo.addEventListener('input', () => {
        AppState.tempo = parseInt(UI.elements.tempo.value);
        UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
        if (AppState.isPlaying) {
            stopPlayback();
            startPlayback();
        }
    });

    UI.elements.timeSignature.addEventListener('change', () => {
        createBeats();
        if (AppState.isPlaying) {
            stopPlayback();
            startPlayback();
        }
    });

    UI.elements.soundType.addEventListener('change', createBeats);

    UI.elements.metronomeVolume.addEventListener('input', () => {
        createBeats();
    });

    UI.elements.progressionSelect.addEventListener('change', () => {
        loadProgression(UI.elements.progressionSelect.value);
    });

    UI.elements.keySelect.addEventListener('change', () => {
        updateProgressionKey(UI.elements.keySelect.value);
        initializeFretFlow();
    });

    UI.elements.chordTuning.addEventListener('change', () => {
        const tuning = TUNINGS[UI.elements.chordTuning.value];
        const firstMeasure = UI.elements.measures.firstElementChild;
        if (firstMeasure) {
            const scaleRoot = firstMeasure.querySelector('.second-key').value;
            const scaleType = firstMeasure.querySelector('.scale-select').value;
            updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning);
        }
        initializeFretFlow();
    });

    UI.elements.tapTempo.addEventListener('click', () => {
        const now = Date.now();
        if (!AppState.lastTap) AppState.lastTap = now;
        const interval = now - AppState.lastTap;
        if (interval < 2000) {
            const bpm = Math.round(60000 / interval);
            AppState.tempo = Math.max(40, Math.min(220, bpm));
            UI.elements.tempo.value = AppState.tempo;
            UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
            if (AppState.isPlaying) {
                stopPlayback();
                startPlayback();
            }
        }
        AppState.lastTap = now;
    });

    UI.elements.darkModeToggle.addEventListener('click', () => {
        AppState.darkMode = !AppState.darkMode;
        document.body.classList.toggle('dark-mode', AppState.darkMode);
        UI.elements.darkModeToggle.classList.toggle('active', AppState.darkMode);
        log(`Dark mode ${AppState.darkMode ? 'enabled' : 'disabled'}`);
    });

    UI.elements.chordFretboardVolume.addEventListener('input', () => {
        log(`Chord fretboard volume set to ${UI.elements.chordFretboardVolume.value}`);
    });

    UI.elements.chordVolume.addEventListener('input', () => {
        log(`Chord volume set to ${UI.elements.chordVolume.value}`);
    });

    UI.elements.fretboardVolume.addEventListener('input', () => {
        log(`Fretboard volume set to ${UI.elements.fretboardVolume.value}`);
    });

    UI.elements.chordsEnabled.addEventListener('change', () => {
        log(`Chords ${UI.elements.chordsEnabled.checked ? 'enabled' : 'disabled'}`);
    });

    UI.elements.measures.addEventListener('change', (e) => {
        if (e.target.classList.contains('root-note') || e.target.classList.contains('chord-quality')) {
            const measure = e.target.closest('.measure');
            const root = measure.querySelector('.root-note').value;
            const quality = measure.querySelector('.chord-quality').value;
            const secondKeySelect = measure.querySelector('.second-key');
            const scaleSelect = measure.querySelector('.scale-select');
            secondKeySelect.value = root;
            scaleSelect.value = suggestScaleForQuality(quality);
            if (measure === UI.elements.measures.firstElementChild) {
                const tuning = TUNINGS[UI.elements.chordTuning.value];
                updateFretboardNotes(UI.elements.chordFretboard, root, scaleSelect.value, tuning);
            }
            log(`Updated chord in measure to ${root} ${quality}`);
        }
    });

    log("Event listeners set up");
}

// Initialization
async function initializeApp() {
    UI.init();
    await AudioContextManager.initialize();
    createBeats();
    createFretboard(UI.elements.chordFretboard, TUNINGS.standard);
    loadProgression(UI.elements.progressionSelect.value);
    initializeFretFlow();
    setupEventListeners();
    updateLoadingStatus("Application initialized");
    setTimeout(() => {
        const indicator = document.getElementById('loading-indicator');
        if (indicator) indicator.remove();
    }, 1000);
    log("Application initialized");
}

// Start the app
document.addEventListener('DOMContentLoaded', () => {
    initializeApp().catch(error => {
        console.error("Initialization failed:", error);
        updateLoadingStatus("Initialization failed");
    });
});
</script>
            </script>
        </body>
        </html>
